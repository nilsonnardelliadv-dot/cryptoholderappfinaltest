<!DOCTYPE html>
<html lang="pt-BR" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoPanelPRO - Versão Holder (CoinGecko)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* CSS otimizado para mobile e layout compacto */
        :root {
            --color-dark-950: #05070a;
            --color-dark-900: #0b0e14;
            --color-dark-800: #151a23;
            --color-dark-700: #232a3b;
            --color-dark-600: #374151;
            --color-brand-500: #3b82f6;
            --color-brand-600: #2563eb;
            --color-green-500: #10b981;
            --color-red-500: #ef4444;
            --color-yellow-500: #f59e0b;
        }

        body { 
            background-color: var(--color-dark-950); 
            color: #e5e7eb; 
            overflow-x: hidden;
            font-family: 'Inter', sans-serif;
        }

        /* Scrollbar personalizada */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--color-dark-900); }
        ::-webkit-scrollbar-thumb { background: var(--color-dark-700); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--color-brand-500); }

        /* Classes utilitárias */
        .glass {
            background: rgba(11, 14, 20, 0.95);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .compact-table th, .compact-table td {
            padding: 0.375rem 0.5rem !important;
            font-size: 0.75rem;
            vertical-align: middle;
        }

        .mobile-optimized {
            font-size: 0.875rem;
        }

        .table-row-high { background-color: rgba(16, 185, 129, 0.1) !important; }
        .table-row-mid { background-color: rgba(59, 130, 246, 0.1) !important; }
        .table-row-low { background-color: rgba(239, 68, 68, 0.1) !important; }

        /* Badges de assimetria */
        .asymmetry-badge {
            font-size: 0.7rem;
            padding: 0.125rem 0.5rem;
            border-radius: 0.75rem;
            font-weight: 800;
            text-transform: uppercase;
        }
        .asymmetry-very-high { background-color: rgba(16, 185, 129, 0.2); border: 1px solid #10b981; color: #10b981; }
        .asymmetry-high { background-color: rgba(34, 197, 94, 0.2); border: 1px solid #22c55e; color: #22c55e; }
        .asymmetry-medium { background-color: rgba(245, 158, 11, 0.2); border: 1px solid #f59e0b; color: #f59e0b; }
        .asymmetry-low { background-color: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444; color: #ef4444; }

        /* Progress bar para score */
        .score-bar {
            height: 4px;
            width: 100%;
            background-color: var(--color-dark-600);
            border-radius: 2px;
            overflow: hidden;
        }
        .score-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        /* Layout de duas colunas para desktop */
        @media (min-width: 1024px) {
            .main-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 1rem;
            }
            .top-10-section {
                grid-column: 1;
            }
            .other-coins-section {
                grid-column: 2;
                max-height: 600px;
                overflow-y: auto;
            }
        }

        /* Tooltips educacionais */
        .metric-tooltip {
            position: absolute;
            background: var(--color-dark-900);
            border: 1px solid var(--color-dark-700);
            border-radius: 0.5rem;
            padding: 1rem;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            display: none;
        }
        .metric-tooltip.show {
            display: block;
        }
        .metric-tooltip h4 {
            color: var(--color-brand-500);
            font-weight: 700;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }
        .metric-tooltip p {
            font-size: 0.75rem;
            color: #d1d5db;
            line-height: 1.4;
        }
        .metric-tooltip .tip-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #60a5fa;
            font-weight: 800;
            margin-top: 0.75rem;
            display: block;
        }

        /* Animações */
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-slide-in {
            animation: slideIn 0.3s ease-out;
        }
    </style>
</head>
<body class="antialiased min-h-screen flex flex-col font-sans selection:bg-brand-500 selection:text-white">

    <!-- Header Compacto -->
    <header class="glass sticky top-0 z-50 border-b border-gray-800 shadow-lg">
        <div class="max-w-[1800px] mx-auto px-2 sm:px-4 h-14 flex items-center justify-between">
            <div class="flex items-center gap-2">
                <div class="w-8 h-8 bg-gradient-to-br from-brand-600 to-indigo-800 rounded-lg flex items-center justify-center">
                    <i class="fa-solid fa-layer-group text-white text-sm"></i>
                </div>
                <div>
                    <h1 class="font-bold text-sm text-white">CryptoPanel<span class="text-brand-500">HOLDER</span></h1>
                    <div class="text-[8px] text-gray-400 font-mono mt-0.5" id="last-update">Conectando...</div>
                </div>
            </div>
            <div class="flex items-center gap-1">
                <button id="refreshData" class="p-2 bg-brand-600 hover:bg-brand-500 rounded-lg text-white">
                    <i class="fa-solid fa-rotate text-sm"></i>
                </button>
                <button onclick="App.Portfolio.openModal()" class="p-2 bg-dark-800 border border-gray-700 rounded-lg" title="Portfólio">
                    <i class="fa-solid fa-wallet text-sm"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Filtros Compactos -->
    <div class="bg-dark-900 border-b border-gray-800 py-2 px-2">
        <div class="flex flex-wrap gap-2 items-center justify-between">
            <div class="flex flex-wrap gap-1">
                <button class="filter-btn px-2 py-1 bg-dark-800 border border-gray-700 rounded text-[10px] hover:bg-dark-700 active-filter" data-filter="all">Todas</button>
                <button class="filter-btn px-2 py-1 bg-dark-800 border border-gray-700 rounded text-[10px] hover:bg-dark-700" data-filter="score_high">Score Alto</button>
                <button class="filter-btn px-2 py-1 bg-dark-800 border border-gray-700 rounded text-[10px] hover:bg-dark-700" data-filter="asymmetry_high">Assimetria Alta</button>
            </div>
            <div class="flex items-center gap-2">
                <input type="text" id="searchToken" placeholder="Buscar..." class="bg-dark-800 border border-gray-700 rounded px-2 py-1 text-xs w-32" />
                <button onclick="App.Token.addFromSearch()" class="px-2 py-1 bg-brand-600 hover:bg-brand-500 text-white rounded text-xs">
                    <i class="fa-solid fa-plus"></i>
                </button>
            </div>
        </div>
    </div>

    <main class="flex-1 max-w-[1800px] mx-auto px-2 py-3 w-full">
        <!-- Layout Principal: Top 10 fixo + Outras moedas com scroll -->
        <div class="main-grid">
            <!-- TOP 10 Oportunidades (Fixo) -->
            <section class="glass rounded-xl overflow-hidden border border-gray-800 top-10-section mb-4 lg:mb-0">
                <div class="bg-dark-800/80 p-3 border-b border-gray-700">
                    <h3 class="text-white font-bold text-sm flex items-center gap-2">
                        <i class="fa-solid fa-crown text-yellow-500"></i> 
                        Top 10 Oportunidades
                    </h3>
                </div>
                <div class="overflow-x-auto">
                    <table class="w-full compact-table">
                        <thead class="text-gray-400 uppercase text-[10px] bg-dark-900">
                            <tr>
                                <th class="p-2 text-center w-8">#</th>
                                <th class="p-2">Token</th>
                                <th class="p-2 text-right">Preço</th>
                                <th class="p-2 text-right">Score</th>
                                <th class="p-2 text-center">Assim</th>
                            </tr>
                        </thead>
                        <tbody id="top10-table-body" class="divide-y divide-gray-800">
                            <!-- Top 10 será renderizado aqui -->
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- OUTRAS MOEDAS (Scroll vertical) -->
            <section class="glass rounded-xl overflow-hidden border border-gray-800 other-coins-section">
                <div class="bg-dark-800/80 p-3 border-b border-gray-700">
                    <h3 class="text-white font-bold text-sm flex items-center gap-2">
                        <i class="fa-solid fa-list text-gray-500"></i> 
                        Outras Moedas (<span id="other-count">0</span>)
                    </h3>
                </div>
                <div class="overflow-y-auto" style="max-height: 500px;">
                    <table class="w-full compact-table">
                        <thead class="text-gray-400 uppercase text-[10px] bg-dark-900 sticky top-0">
                            <tr>
                                <th class="p-2">Token</th>
                                <th class="p-2 text-right">Preço</th>
                                <th class="p-2 text-right">MCap</th>
                                <th class="p-2 text-right">Score</th>
                                <th class="p-2 text-center">RSI</th>
                            </tr>
                        </thead>
                        <tbody id="other-table-body" class="divide-y divide-gray-800">
                            <!-- Outras moedas serão renderizadas aqui -->
                        </tbody>
                    </table>
                </div>
            </section>
        </div>

        <!-- Cards Detalhados (Apenas para moedas selecionadas) -->
        <div class="mt-4">
            <h3 class="text-white font-bold text-sm mb-2">Análise Detalhada</h3>
            <div id="cards-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                <!-- Cards serão renderizados aqui -->
            </div>
        </div>
    </main>

    <!-- Modal de Adicionar Token -->
    <div id="addTokenModal" class="fixed inset-0 z-50 hidden bg-black/80 flex items-center justify-center p-4">
        <div class="bg-dark-900 border border-gray-700 rounded-xl w-full max-w-md">
            <div class="p-4 border-b border-gray-700 flex justify-between items-center">
                <h3 class="text-white font-bold">Adicionar Token</h3>
                <button onclick="document.getElementById('addTokenModal').classList.add('hidden')" class="text-gray-500 hover:text-white">
                    <i class="fa-solid fa-times"></i>
                </button>
            </div>
            <div class="p-4">
                <input type="text" id="token-search-input" placeholder="Digite o nome ou símbolo (ex: bitcoin)" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white mb-3" />
                <div id="search-results" class="space-y-2 max-h-60 overflow-y-auto"></div>
            </div>
        </div>
    </div>

    <!-- Tooltip Educacional (Dinâmico) -->
    <div id="metric-tooltip" class="metric-tooltip"></div>

    <script>
        // ============================================================================
        // CONFIGURAÇÕES E CONSTANTES
        // ============================================================================
        const COINGECKO_API = "https://api.coingecko.com/api/v3";
        const CACHE_DURATION = 15 * 60 * 1000; // 15 minutos
        const MAX_CONCURRENT_REQUESTS = 3;

        // ============================================================================
        // ESTADO GLOBAL DO APLICATIVO
        // ============================================================================
        const AppState = {
            // Tokens favoritos (apenas estes serão analisados)
            favoriteTokens: JSON.parse(localStorage.getItem('holder_favorites')) || ['bitcoin', 'ethereum'],
            
            // Dados das moedas
            coinData: {}, // Dados básicos da CoinGecko
            technicalData: {}, // Indicadores técnicos calculados
            ohlcData: {}, // Dados OHLC em cache
            
            // Configurações
            settings: {
                autoRefresh: true,
                refreshInterval: 300000, // 5 minutos
                showTop10: true,
                compactView: true
            },
            
            // Estado da UI
            activeFilter: 'all',
            sortBy: 'score_desc',
            isLoading: false
        };

        // ============================================================================
        // BIBLIOTECA DE INDICADORES TÉCNICOS (100% TradingView Compatível)
        // ============================================================================
        const TechnicalIndicators = {
            /**
             * RSI - Relative Strength Index (Método de Wilder)
             * Implementação idêntica ao TradingView
             */
            calculateRSI: function(closes, period = 14) {
                if (closes.length < period + 1) return 50;
                
                let gains = [];
                let losses = [];
                
                // Calcula ganhos e perdas
                for (let i = 1; i < closes.length; i++) {
                    const change = closes[i] - closes[i - 1];
                    gains.push(change > 0 ? change : 0);
                    losses.push(change < 0 ? -change : 0);
                }
                
                // Médias iniciais
                let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
                let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
                
                // Suavização Wilder (RMA)
                for (let i = period; i < gains.length; i++) {
                    avgGain = (avgGain * (period - 1) + gains[i]) / period;
                    avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
                }
                
                if (avgLoss === 0) return 100;
                const rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            },

            /**
             * EMA - Exponential Moving Average
             */
            calculateEMA: function(closes, period) {
                if (closes.length < period) return null;
                
                const k = 2 / (period + 1);
                let ema = closes.slice(0, period).reduce((a, b) => a + b, 0) / period;
                
                for (let i = period; i < closes.length; i++) {
                    ema = closes[i] * k + ema * (1 - k);
                }
                
                return ema;
            },

            /**
             * SMA - Simple Moving Average
             */
            calculateSMA: function(closes, period) {
                if (closes.length < period) return null;
                const slice = closes.slice(-period);
                return slice.reduce((a, b) => a + b, 0) / period;
            },

            /**
             * MACD - Moving Average Convergence Divergence (12, 26, 9)
             * Implementação padrão TradingView
             */
            calculateMACD: function(closes) {
                if (closes.length < 26) return { macd: 0, signal: 0, histogram: 0 };
                
                // Calcula EMA12 e EMA26 para cada ponto
                const ema12Array = [];
                const ema26Array = [];
                
                // EMA inicial
                let ema12 = closes.slice(0, 12).reduce((a, b) => a + b, 0) / 12;
                let ema26 = closes.slice(0, 26).reduce((a, b) => a + b, 0) / 26;
                
                ema12Array.push(ema12);
                ema26Array.push(ema26);
                
                // Calcula EMAs subsequentes
                const k12 = 2 / (12 + 1);
                const k26 = 2 / (26 + 1);
                
                for (let i = 12; i < closes.length; i++) {
                    ema12 = closes[i] * k12 + ema12 * (1 - k12);
                    ema12Array.push(ema12);
                }
                
                for (let i = 26; i < closes.length; i++) {
                    ema26 = closes[i] * k26 + ema26 * (1 - k26);
                    ema26Array.push(ema26);
                }
                
                // Calcula MACD line (começa do ponto 26)
                const macdLine = [];
                const startIdx = Math.max(ema12Array.length, ema26Array.length) - Math.min(ema12Array.length, ema26Array.length);
                
                for (let i = startIdx; i < Math.min(ema12Array.length, ema26Array.length); i++) {
                    macdLine.push(ema12Array[i] - ema26Array[i]);
                }
                
                if (macdLine.length < 9) return { macd: macdLine[macdLine.length - 1] || 0, signal: 0, histogram: 0 };
                
                // Calcula Signal line (EMA9 do MACD)
                let signal = macdLine.slice(0, 9).reduce((a, b) => a + b, 0) / 9;
                const kSignal = 2 / (9 + 1);
                
                for (let i = 9; i < macdLine.length; i++) {
                    signal = macdLine[i] * kSignal + signal * (1 - kSignal);
                }
                
                const currentMACD = macdLine[macdLine.length - 1] || 0;
                const histogram = currentMACD - signal;
                
                return {
                    macd: currentMACD,
                    signal: signal,
                    histogram: histogram
                };
            },

            /**
             * Volatilidade - Log Returns Anualizada
             * Método profissional (mesmo do TradingView)
             */
            calculateVolatility: function(closes) {
                if (closes.length < 2) return 0;
                
                // Calcula log returns
                const returns = [];
                for (let i = 1; i < closes.length; i++) {
                    returns.push(Math.log(closes[i] / closes[i - 1]));
                }
                
                // Desvio padrão dos returns
                const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
                const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
                const stdDev = Math.sqrt(variance);
                
                // Anualização (assumindo dados diários)
                return stdDev * Math.sqrt(365) * 100;
            },

            /**
             * Calcula todos os indicadores para um conjunto de preços
             */
            calculateAllIndicators: function(closes) {
                return {
                    rsi: this.calculateRSI(closes, 14),
                    sma30: this.calculateSMA(closes, 30),
                    sma200: this.calculateSMA(closes, 200),
                    ema30: this.calculateEMA(closes, 30),
                    ema200: this.calculateEMA(closes, 200),
                    macd: this.calculateMACD(closes),
                    volatility: this.calculateVolatility(closes),
                    momentum30: closes.length >= 30 ? 
                        ((closes[closes.length - 1] / closes[closes.length - 30] - 1) * 100) : 0,
                    momentum90: closes.length >= 90 ? 
                        ((closes[closes.length - 1] / closes[closes.length - 90] - 1) * 100) : 0
                };
            }
        };

        // ============================================================================
        // SISTEMA DE PONTUAÇÃO HOLDER (COMEÇA EM 0, PENALIDADES NEGATIVAS)
        // ============================================================================
        const HolderScoring = {
            /**
             * Calcula score completo para um token
             * INÍCIO: score = 0
             * SUBPONTUAÇÕES PODEM SER NEGATIVAS
             * CLAMP FINAL: 0-100
             */
            calculateScore: function(coinId) {
                const coin = AppState.coinData[coinId];
                const tech = AppState.technicalData[coinId];
                
                if (!coin || !tech) return 0;
                
                let score = 0;
                
                // 1. FUNDAMENTOS (40 pontos) - PENALIDADES FORTES
                let fundamentals = 0;
                
                // Market Cap (penalidades severas para microcaps)
                const marketCap = coin.market_cap || 0;
                if (marketCap < 50000000) fundamentals -= 25; // < 50M
                if (marketCap < 25000000) fundamentals -= 10; // < 25M
                if (marketCap < 10000000) fundamentals -= 15; // < 10M
                
                // Volume (penalidade por baixa liquidez)
                const volume = coin.total_volume || 0;
                if (volume < 5000000) fundamentals -= 10; // < 5M
                if (volume < 2000000) fundamentals -= 5;  // < 2M
                
                // Volume/MCap Ratio (bônus por liquidez)
                if (marketCap > 0) {
                    const ratio = (volume / marketCap) * 100;
                    if (ratio > 10) fundamentals += 10;
                    else if (ratio > 5) fundamentals += 5;
                    else if (ratio > 2) fundamentals += 2;
                    else if (ratio < 0.5) fundamentals -= 5;
                }
                
                // Penalidade dupla para microcaps sem volume
                if (marketCap < 50000000 && volume < 2000000) {
                    fundamentals -= 10;
                }
                
                score += fundamentals;
                
                // 2. VALUATION (30 pontos) - DISTÂNCIA DO ATH
                let valuation = 0;
                
                const athDistance = coin.ath_change_percentage || 0; // Percentual abaixo do ATH
                
                // Quanto mais longe do ATH (em tendência saudável), mais pontos
                if (athDistance > 80) valuation += 15;  // >80% abaixo
                else if (athDistance > 60) valuation += 12;
                else if (athDistance > 40) valuation += 8;
                else if (athDistance > 20) valuation += 4;
                else if (athDistance > 0) valuation += 1;
                else if (athDistance < 0) valuation -= 15; // Acima do ATH (penalidade)
                
                // Indicadores técnicos de valuation
                if (tech.rsi < 30) valuation += 8;  // Oversold forte
                else if (tech.rsi < 40) valuation += 4;
                else if (tech.rsi > 70) valuation -= 8;  // Overbought
                
                // Distância para médias móveis
                if (tech.sma30 && coin.current_price) {
                    const distToMA30 = ((coin.current_price - tech.sma30) / tech.sma30) * 100;
                    if (distToMA30 < -20) valuation += 5;  // Muito abaixo da MA30
                    else if (distToMA30 > 30) valuation -= 5; // Muito acima da MA30
                }
                
                score += valuation;
                
                // 3. MOMENTUM (20 pontos) - RETORNOS REAIS
                let momentum = 0;
                
                // Momentum baseado em retornos reais
                if (tech.momentum30 < -40) momentum += 10; // Queda extrema
                else if (tech.momentum30 < -20) momentum += 7;
                else if (tech.momentum30 < 0) momentum += 3;
                else if (tech.momentum30 > 50) momentum -= 10; // Alta extrema (sobrecompra)
                else if (tech.momentum30 > 20) momentum -= 5;
                
                // Momentum de longo prazo
                if (tech.momentum90 < -60) momentum += 10;
                else if (tech.momentum90 < -30) momentum += 5;
                else if (tech.momentum90 > 100) momentum -= 10;
                
                score += momentum;
                
                // 4. RISCO (10 pontos) - VOLATILIDADE E SUPPLY
                let risk = 0;
                
                // Supply Risk
                if (coin.circulating_supply && coin.max_supply) {
                    const circRatio = (coin.circulating_supply / coin.max_supply) * 100;
                    if (circRatio > 90) risk += 7;  // Maior parte em circulação
                    else if (circRatio > 70) risk += 4;
                    else if (circRatio < 30) risk -= 5; // Muita inflação por vir
                } else if (!coin.max_supply) {
                    risk -= 3; // Sem max supply definido
                }
                
                // Volatilidade (penaliza alta volatilidade)
                if (tech.volatility > 15) risk -= 3;
                else if (tech.volatility > 10) risk -= 2;
                else if (tech.volatility < 5) risk += 2; // Baixa volatilidade (bom)
                
                // Microcaps voláteis: penalização dupla
                if (marketCap < 50000000 && tech.volatility > 20) {
                    risk -= 5;
                }
                
                score += risk;
                
                // 5. BÔNUS DE ASSIMETRIA (condicional)
                const asymmetry = this.calculateAsymmetry(coinId);
                
                // Bônus só aplica se fundamentos não forem catastróficos
                if (fundamentals >= 20) {
                    if (asymmetry.ratio > 4) score += 15;
                    else if (asymmetry.ratio > 3) score += 10;
                    else if (asymmetry.ratio > 2) score += 5;
                } else {
                    // Bônus reduzido para tokens com fundamentos ruins
                    if (asymmetry.ratio > 4) score += 5;
                    else if (asymmetry.ratio > 3) score += 3;
                }
                
                // CLAMP FINAL: 0-100
                return Math.max(0, Math.min(100, Math.round(score)));
            },

            /**
             * Calcula assimetria realista (risco/recompensa)
             * Ajusta ATH se for pico manipulatório
             */
            calculateAsymmetry: function(coinId) {
                const coin = AppState.coinData[coinId];
                const tech = AppState.technicalData[coinId];
                
                if (!coin || !tech) return { upside: 0, downside: 0, ratio: 0, classification: 'low' };
                
                // UPSIDE: Potencial até o ATH (com ajustes)
                let upside = 0;
                if (coin.ath && coin.current_price && coin.current_price > 0) {
                    upside = ((coin.ath / coin.current_price) - 1) * 100;
                    
                    // Ajuste para ATHs manipulatórios (se volume no ATH era baixo)
                    // Nota: CoinGecko não fornece volume no ATH, então usamos heurística
                    if (upside > 1000 && coin.market_cap < 100000000) {
                        upside = Math.min(upside, 500); // Limita upside absurdo de microcaps
                    }
                }
                
                // DOWNSIDE: Combinação de fatores de risco
                let downside = 25; // Baseline
                
                // 1. Distância para SMA200 (suporte de longo prazo)
                if (tech.sma200 && coin.current_price) {
                    const distToSMA200 = Math.abs((coin.current_price - tech.sma200) / coin.current_price) * 100;
                    downside = Math.max(downside, distToSMA200 * 1.5);
                }
                
                // 2. Volatilidade (risco de oscilação)
                downside = Math.max(downside, tech.volatility * 1.2);
                
                // 3. Drawdown estrutural (quão fundo já caiu)
                const athDistance = coin.ath_change_percentage || 0;
                if (athDistance > 70) {
                    downside = Math.max(downside, 40); // Já caiu muito, risco de cair mais
                }
                
                // 4. Liquidez (penalidade por baixo volume)
                const volumeRatio = coin.total_volume && coin.market_cap ? 
                    (coin.total_volume / coin.market_cap) * 100 : 0;
                if (volumeRatio < 1) {
                    downside += 15; // Baixíssima liquidez
                } else if (volumeRatio < 5) {
                    downside += 5;
                }
                
                // Calcular razão
                let ratio = 0;
                if (downside > 0) {
                    ratio = upside / downside;
                }
                
                // Classificação
                let classification = 'low';
                if (ratio > 4) classification = 'very-high';
                else if (ratio > 3) classification = 'high';
                else if (ratio > 2) classification = 'medium';
                
                return {
                    upside: Math.round(upside * 10) / 10,
                    downside: Math.round(downside * 10) / 10,
                    ratio: Math.round(ratio * 10) / 10,
                    classification: classification
                };
            }
        };

        // ============================================================================
        // PIPELINE DE CARREGAMENTO E CACHE
        // ============================================================================
        const DataPipeline = {
            /**
             * Busca dados OHLC com cache inteligente
             */
            fetchOHLC: async function(coinId, days = 90) {
                const cacheKey = `ohlc_${coinId}_${days}`;
                const now = Date.now();
                
                // Verifica cache
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    const { data, timestamp } = JSON.parse(cached);
                    if (now - timestamp < CACHE_DURATION) {
                        return data;
                    }
                }
                
                // Busca da API
                try {
                    const response = await fetch(
                        `${COINGECKO_API}/coins/${coinId}/ohlc?vs_currency=usd&days=${days}`
                    );
                    
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const ohlc = await response.json();
                    const closes = ohlc.map(d => d[4]); // Apenas preços de fechamento
                    
                    // Salva no cache
                    localStorage.setItem(cacheKey, JSON.stringify({
                        data: closes,
                        timestamp: now
                    }));
                    
                    return closes;
                } catch (error) {
                    console.error(`Erro ao buscar OHLC de ${coinId}:`, error);
                    return null;
                }
            },

            /**
             * Busca dados básicos dos tokens favoritos
             */
            fetchCoinData: async function(coinIds) {
                if (!coinIds.length) return {};
                
                try {
                    const response = await fetch(
                        `${COINGECKO_API}/coins/markets?vs_currency=usd&ids=${coinIds.join(',')}&order=market_cap_desc&sparkline=false&price_change_percentage=1h,24h,7d,30d,90d`
                    );
                    
                    const coins = await response.json();
                    const coinData = {};
                    
                    coins.forEach(coin => {
                        coinData[coin.id] = coin;
                    });
                    
                    return coinData;
                } catch (error) {
                    console.error('Erro ao buscar dados das moedas:', error);
                    return {};
                }
            },

            /**
             * Pipeline completo: OHLC → Indicadores → Score
             */
            processToken: async function(coinId) {
                // 1. Busca dados básicos (se necessário)
                if (!AppState.coinData[coinId]) {
                    const data = await this.fetchCoinData([coinId]);
                    AppState.coinData[coinId] = data[coinId];
                }
                
                // 2. Busca OHLC
                const closes = await this.fetchOHLC(coinId, 90);
                if (!closes || closes.length < 30) {
                    console.warn(`Dados insuficientes para ${coinId}`);
                    return false;
                }
                
                // 3. Calcula indicadores
                AppState.technicalData[coinId] = TechnicalIndicators.calculateAllIndicators(closes);
                
                // 4. Calcula score
                const score = HolderScoring.calculateScore(coinId);
                AppState.coinData[coinId].holderScore = score;
                
                // 5. Calcula assimetria
                AppState.coinData[coinId].asymmetry = HolderScoring.calculateAsymmetry(coinId);
                
                return true;
            },

            /**
             * Processa todos os tokens com limite de concorrência
             */
            processAllTokens: async function() {
                const tokens = AppState.favoriteTokens;
                AppState.isLoading = true;
                
                // Limite de requests concorrentes
                const batchSize = MAX_CONCURRENT_REQUESTS;
                for (let i = 0; i < tokens.length; i += batchSize) {
                    const batch = tokens.slice(i, i + batchSize);
                    await Promise.all(batch.map(token => this.processToken(token)));
                    
                    // Atualiza UI progressivamente
                    UI.updateTables();
                }
                
                AppState.isLoading = false;
                UI.updateLastUpdate();
            }
        };

        // ============================================================================
        // INTERFACE DO USUÁRIO (UI)
        // ============================================================================
        const UI = {
            /**
             * Renderiza tabela do Top 10
             */
            renderTop10: function() {
                const tbody = document.getElementById('top10-table-body');
                if (!tbody) return;
                
                // Ordena tokens por score
                const sortedTokens = [...AppState.favoriteTokens]
                    .filter(id => AppState.coinData[id])
                    .sort((a, b) => {
                        const scoreA = AppState.coinData[a]?.holderScore || 0;
                        const scoreB = AppState.coinData[b]?.holderScore || 0;
                        return scoreB - scoreA;
                    })
                    .slice(0, 10);
                
                tbody.innerHTML = '';
                
                sortedTokens.forEach((coinId, index) => {
                    const coin = AppState.coinData[coinId];
                    if (!coin) return;
                    
                    const score = coin.holderScore || 0;
                    const asymmetry = coin.asymmetry || { ratio: 0, classification: 'low' };
                    
                    const row = document.createElement('tr');
                    row.className = `table-row-${score > 70 ? 'high' : score < 40 ? 'low' : 'mid'} hover:bg-dark-800/50`;
                    
                    row.innerHTML = `
                        <td class="p-2 text-center text-gray-500 font-bold">${index + 1}</td>
                        <td class="p-2">
                            <div class="flex items-center gap-2">
                                <img src="${coin.image}" alt="${coin.name}" class="w-6 h-6 rounded-full">
                                <div>
                                    <div class="font-bold text-white">${coin.symbol.toUpperCase()}</div>
                                    <div class="text-[10px] text-gray-500">${coin.name}</div>
                                </div>
                            </div>
                        </td>
                        <td class="p-2 text-right font-mono text-white">$${coin.current_price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 4 })}</td>
                        <td class="p-2 text-right">
                            <div class="flex flex-col items-end">
                                <div class="font-bold ${score > 70 ? 'text-green-400' : score < 40 ? 'text-red-400' : 'text-blue-400'}">${score}</div>
                                <div class="score-bar w-12 mt-1">
                                    <div class="score-fill ${score > 70 ? 'bg-green-500' : score < 40 ? 'bg-red-500' : 'bg-blue-500'}" style="width: ${score}%"></div>
                                </div>
                            </div>
                        </td>
                        <td class="p-2 text-center">
                            <div class="asymmetry-badge asymmetry-${asymmetry.classification}" title="Assimetria ${asymmetry.ratio}:1">
                                ${asymmetry.ratio.toFixed(1)}
                            </div>
                        </td>
                    `;
                    
                    tbody.appendChild(row);
                });
            },

            /**
             * Renderiza tabela de outras moedas
             */
            renderOtherCoins: function() {
                const tbody = document.getElementById('other-table-body');
                const countEl = document.getElementById('other-count');
                if (!tbody || !countEl) return;
                
                // Ordena tokens por score (excluindo top 10)
                const allTokens = [...AppState.favoriteTokens]
                    .filter(id => AppState.coinData[id])
                    .sort((a, b) => {
                        const scoreA = AppState.coinData[a]?.holderScore || 0;
                        const scoreB = AppState.coinData[b]?.holderScore || 0;
                        return scoreB - scoreA;
                    });
                
                const otherTokens = allTokens.slice(10);
                countEl.textContent = otherTokens.length;
                
                tbody.innerHTML = '';
                
                otherTokens.forEach(coinId => {
                    const coin = AppState.coinData[coinId];
                    if (!coin) return;
                    
                    const score = coin.holderScore || 0;
                    const tech = AppState.technicalData[coinId] || { rsi: 50 };
                    
                    const row = document.createElement('tr');
                    row.className = `table-row-${score > 70 ? 'high' : score < 40 ? 'low' : 'mid'} hover:bg-dark-800/50`;
                    
                    row.innerHTML = `
                        <td class="p-2">
                            <div class="flex items-center gap-2">
                                <img src="${coin.image}" alt="${coin.name}" class="w-5 h-5 rounded-full">
                                <div class="font-bold text-white">${coin.symbol.toUpperCase()}</div>
                            </div>
                        </td>
                        <td class="p-2 text-right font-mono text-white">$${coin.current_price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: coin.current_price < 1 ? 6 : 2 })}</td>
                        <td class="p-2 text-right font-mono text-gray-400">
                            ${this.formatMarketCap(coin.market_cap)}
                        </td>
                        <td class="p-2 text-right">
                            <div class="font-bold ${score > 70 ? 'text-green-400' : score < 40 ? 'text-red-400' : 'text-blue-400'}">${score}</div>
                        </td>
                        <td class="p-2 text-center font-mono ${tech.rsi < 30 ? 'text-green-400' : tech.rsi > 70 ? 'text-red-400' : 'text-white'}">
                            ${tech.rsi ? tech.rsi.toFixed(0) : '--'}
                        </td>
                    `;
                    
                    tbody.appendChild(row);
                });
            },

            /**
             * Atualiza ambas as tabelas
             */
            updateTables: function() {
                this.renderTop10();
                this.renderOtherCoins();
                this.renderCards();
            },

            /**
             * Renderiza cards detalhados
             */
            renderCards: function() {
                const grid = document.getElementById('cards-grid');
                if (!grid) return;
                
                grid.innerHTML = '';
                
                AppState.favoriteTokens.forEach(coinId => {
                    const coin = AppState.coinData[coinId];
                    const tech = AppState.technicalData[coinId];
                    if (!coin || !tech) return;
                    
                    const card = document.createElement('div');
                    card.className = 'glass rounded-lg p-3 border border-gray-800 animate-slide-in';
                    
                    const score = coin.holderScore || 0;
                    const asymmetry = coin.asymmetry || { ratio: 0, classification: 'low' };
                    
                    card.innerHTML = `
                        <div class="flex justify-between items-start mb-2">
                            <div class="flex items-center gap-2">
                                <img src="${coin.image}" alt="${coin.name}" class="w-8 h-8 rounded-full">
                                <div>
                                    <div class="font-bold text-white">${coin.symbol.toUpperCase()}</div>
                                    <div class="text-[10px] text-gray-500">${coin.name}</div>
                                </div>
                            </div>
                            <div class="text-right">
                                <div class="font-mono text-white">$${coin.current_price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 4 })}</div>
                                <div class="text-[10px] ${coin.ath_change_percentage > 50 ? 'text-green-400' : 'text-yellow-400'}">
                                    ${coin.ath_change_percentage ? coin.ath_change_percentage.toFixed(1) + '% do ATH' : ''}
                                </div>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-2 mt-3 text-[10px]">
                            <div class="text-center p-1 bg-dark-800 rounded">
                                <div class="text-gray-500">Score</div>
                                <div class="font-bold ${score > 70 ? 'text-green-400' : score < 40 ? 'text-red-400' : 'text-blue-400'}">${score}</div>
                            </div>
                            <div class="text-center p-1 bg-dark-800 rounded">
                                <div class="text-gray-500">Assimetria</div>
                                <div class="font-bold ${asymmetry.ratio > 3 ? 'text-green-400' : asymmetry.ratio > 2 ? 'text-yellow-400' : 'text-red-400'}">${asymmetry.ratio.toFixed(1)}:1</div>
                            </div>
                            <div class="text-center p-1 bg-dark-800 rounded">
                                <div class="text-gray-500">RSI</div>
                                <div class="font-bold ${tech.rsi < 30 ? 'text-green-400' : tech.rsi > 70 ? 'text-red-400' : 'text-white'}">${tech.rsi.toFixed(0)}</div>
                            </div>
                            <div class="text-center p-1 bg-dark-800 rounded">
                                <div class="text-gray-500">Vol</div>
                                <div class="font-bold">${tech.volatility.toFixed(1)}%</div>
                            </div>
                        </div>
                        
                        <div class="mt-3 text-[10px] space-y-1">
                            <div class="flex justify-between">
                                <span class="text-gray-500">Market Cap:</span>
                                <span class="text-white">${this.formatMarketCap(coin.market_cap)}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-500">Volume 24h:</span>
                                <span class="text-white">${this.formatMarketCap(coin.total_volume)}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-500">Upside:</span>
                                <span class="text-green-400">${asymmetry.upside.toFixed(1)}%</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-gray-500">Downside:</span>
                                <span class="text-red-400">${asymmetry.downside.toFixed(1)}%</span>
                            </div>
                        </div>
                    `;
                    
                    grid.appendChild(card);
                });
            },

            /**
             * Formata market cap para K/M/B
             */
            formatMarketCap: function(value) {
                if (!value) return '$--';
                if (value >= 1e9) return '$' + (value / 1e9).toFixed(2) + 'B';
                if (value >= 1e6) return '$' + (value / 1e6).toFixed(2) + 'M';
                if (value >= 1e3) return '$' + (value / 1e3).toFixed(2) + 'K';
                return '$' + value.toFixed(2);
            },

            /**
             * Atualiza timestamp da última atualização
             */
            updateLastUpdate: function() {
                const el = document.getElementById('last-update');
                if (el) {
                    const now = new Date();
                    el.textContent = now.toLocaleTimeString('pt-BR', { 
                        hour: '2-digit', 
                        minute: '2-digit',
                        second: '2-digit'
                    });
                }
            },

            /**
             * Mostra tooltip educacional
             */
            showTooltip: function(metric, element) {
                const tooltip = document.getElementById('metric-tooltip');
                if (!tooltip) return;
                
                const tooltips = {
                    score: {
                        title: "Holder Score",
                        content: "Pontuação de 0-100 que avalia oportunidades de investimento de longo prazo. Combina fundamentos, valuation, momentum e risco.",
                        tip: "Score > 70: Excelente oportunidade. Score < 40: Evitar ou considerar venda."
                    },
                    asymmetry: {
                        title: "Assimetria Risco/Recompensa",
                        content: "Razão entre potencial de alta (upside) e risco de queda (downside). Valores > 3:1 indicam boas oportunidades.",
                        tip: "Busque assimetrias altas (>3:1) em tokens com fundamentos sólidos."
                    },
                    rsi: {
                        title: "Relative Strength Index",
                        content: "Indicador de momentum que identifica condições de sobrecompra (>70) e sobrevenda (<30).",
                        tip: "RSI < 30 pode indicar oportunidade de compra. RSI > 70 sugere cautela."
                    },
                    volatility: {
                        title: "Volatilidade Anualizada",
                        content: "Mede a variação dos preços. Alta volatilidade = maior risco, maior potencial retorno.",
                        tip: "Holders podem tolerar mais volatilidade em ativos com alta assimetria."
                    }
                };
                
                const data = tooltips[metric] || tooltips.score;
                
                tooltip.innerHTML = `
                    <h4>${data.title}</h4>
                    <p>${data.content}</p>
                    <span class="tip-label">Dica Holder</span>
                    <p>${data.tip}</p>
                `;
                
                const rect = element.getBoundingClientRect();
                tooltip.style.left = `${rect.left}px`;
                tooltip.style.top = `${rect.bottom + 5}px`;
                tooltip.classList.add('show');
                
                // Remove tooltip após 5 segundos
                setTimeout(() => {
                    tooltip.classList.remove('show');
                }, 5000);
            }
        };

        // ============================================================================
        // GERENCIAMENTO DE TOKENS
        // ============================================================================
        const TokenManager = {
            /**
             * Adiciona token a partir da busca
             */
            addFromSearch: async function() {
                const input = document.getElementById('searchToken');
                const query = input.value.trim().toLowerCase();
                
                if (!query) return;
                
                try {
                    // Busca lista de moedas da CoinGecko
                    const response = await fetch(`${COINGECKO_API}/coins/list`);
                    const allCoins = await response.json();
                    
                    // Encontra a moeda (por símbolo ou nome)
                    const coin = allCoins.find(c => 
                        c.symbol.toLowerCase() === query || 
                        c.id.toLowerCase() === query ||
                        c.name.toLowerCase().includes(query)
                    );
                    
                    if (coin) {
                        if (!AppState.favoriteTokens.includes(coin.id)) {
                            AppState.favoriteTokens.push(coin.id);
                            this.saveFavorites();
                            
                            // Processa o novo token
                            await DataPipeline.processToken(coin.id);
                            UI.updateTables();
                            
                            input.value = '';
                            alert(`${coin.name} adicionado aos favoritos!`);
                        } else {
                            alert('Este token já está na lista!');
                        }
                    } else {
                        alert('Token não encontrado. Use símbolo (ex: btc) ou ID (ex: bitcoin)');
                    }
                } catch (error) {
                    console.error('Erro ao buscar token:', error);
                    alert('Erro ao buscar token. Tente novamente.');
                }
            },

            /**
             * Remove token da lista
             */
            removeToken: function(coinId) {
                AppState.favoriteTokens = AppState.favoriteTokens.filter(id => id !== coinId);
                this.saveFavorites();
                
                // Remove dados do estado
                delete AppState.coinData[coinId];
                delete AppState.technicalData[coinId];
                
                UI.updateTables();
            },

            /**
             * Salva lista de favoritos no localStorage
             */
            saveFavorites: function() {
                localStorage.setItem('holder_favorites', JSON.stringify(AppState.favoriteTokens));
            }
        };

        // ============================================================================
        // INICIALIZAÇÃO DO APLICATIVO
        // ============================================================================
        const App = {
            /**
             * Inicializa o aplicativo
             */
            init: async function() {
                console.log('🚀 CryptoPanel Holder iniciando...');
                
                // 1. Configura event listeners
                this.setupEventListeners();
                
                // 2. Carrega dados iniciais
                if (AppState.favoriteTokens.length > 0) {
                    await DataPipeline.processAllTokens();
                }
                
                // 3. Configura atualização automática
                if (AppState.settings.autoRefresh) {
                    setInterval(async () => {
                        await DataPipeline.processAllTokens();
                    }, AppState.settings.refreshInterval);
                }
                
                console.log('✅ CryptoPanel Holder pronto!');
            },

            /**
             * Configura todos os event listeners
             */
            setupEventListeners: function() {
                // Botão de refresh
                document.getElementById('refreshData').addEventListener('click', async () => {
                    await DataPipeline.processAllTokens();
                });
                
                // Filtros
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active-filter'));
                        this.classList.add('active-filter');
                        AppState.activeFilter = this.dataset.filter;
                        UI.updateTables();
                    });
                });
                
                // Busca
                document.getElementById('searchToken').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        TokenManager.addFromSearch();
                    }
                });
                
                // Tooltips educacionais
                document.addEventListener('mouseover', (e) => {
                    if (e.target.classList.contains('metric-hint')) {
                        const metric = e.target.dataset.metric;
                        UI.showTooltip(metric, e.target);
                    }
                });
            },

            // Exporta funções públicas
            Portfolio: {
                openModal: function() {
                    alert('Modal de portfólio em desenvolvimento...');
                }
            },
            Token: TokenManager
        };

        // ============================================================================
        // INICIALIZAÇÃO AO CARREGAR A PÁGINA
        // ============================================================================
        document.addEventListener('DOMContentLoaded', () => {
            App.init();
        });
    </script>
</body>
</html>
