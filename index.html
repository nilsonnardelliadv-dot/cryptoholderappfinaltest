<!DOCTYPE html>
<html lang="pt-BR" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoPanelPRO HOLDER v13 - Sistema Quantitativo</title>
    
    <!-- Dependencies -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', 'sans-serif'], mono: ['JetBrains Mono', 'monospace'] },
                    colors: {
                        dark: { 950: '#05070a', 900: '#0b0e14', 800: '#151a23', 700: '#232a3b', 600: '#374151' },
                        brand: { 500: '#3b82f6', 600: '#2563eb' },
                        score: { 
                            high: '#10b981', 
                            mid: '#f59e0b', 
                            low: '#ef4444',
                            strong: '#059669',
                            neutral: '#3b82f6',
                            risk: '#dc2626'
                        },
                        holder: {
                            buy: '#059669',
                            hold: '#3b82f6',
                            sell: '#dc2626'
                        }
                    },
                    animation: { 
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'fade-in': 'fadeIn 0.5s ease-in'
                    },
                    keyframes: {
                        fadeIn: { from: { opacity: 0 }, to: { opacity: 1 } }
                    }
                }
            }
        }
    </script>

    <!-- Styles -->
    <style>
        :root {
            --holder-buy: #059669;
            --holder-hold: #3b82f6;
            --holder-sell: #dc2626;
        }
        
        body { 
            background-color: #05070a; 
            color: #e5e7eb; 
            overflow-x: hidden;
            font-family: 'Inter', sans-serif;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0b0e14; }
        ::-webkit-scrollbar-thumb { background: #232a3b; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #3b82f6; }
        
        /* Glass effect */
        .glass { 
            background: rgba(11, 14, 20, 0.95); 
            backdrop-filter: blur(12px); 
            border: 1px solid rgba(255, 255, 255, 0.08); 
        }
        
        /* Table */
        .table-fixed-header thead { 
            position: sticky; 
            top: 0; 
            z-index: 20; 
            background-color: #0b0e14; 
        }
        
        .table-row-hover:hover td { 
            background-color: rgba(59, 130, 246, 0.08); 
        }
        
        /* Cards */
        .holder-card-buy { border-top: 4px solid var(--holder-buy); }
        .holder-card-hold { border-top: 4px solid var(--holder-hold); }
        .holder-card-sell { border-top: 4px solid var(--holder-sell); }
        
        /* Tooltips */
        .metric-tooltip {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: auto;
            max-height: 60vh;
            background-color: #05070a;
            border-top: 1px solid rgba(59, 130, 246, 0.4);
            box-shadow: 0 -10px 60px rgba(0,0,0,0.95);
            z-index: 9999;
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.3s ease;
            overflow-y: auto;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .tooltip-hidden { transform: translateY(110%); opacity: 0; pointer-events: none; }
        .tooltip-visible { transform: translateY(0); opacity: 1; pointer-events: auto; }
        
        /* Loading */
        .loading-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Charts */
        .chart-container { 
            background: #000; 
            border-radius: 8px; 
            border: 1px solid #374151;
            overflow: hidden;
        }
        
        /* Mobile Optimizations */
        @media (max-width: 768px) {
            .mobile-stack { flex-direction: column !important; }
            .mobile-full { width: 100% !important; }
            .mobile-hide { display: none !important; }
            .mobile-text-sm { font-size: 0.875rem; }
        }
        
        /* Progress Bars */
        .progress-bar {
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.1);
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        /* Badges */
        .badge {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .badge-buy { background: rgba(5, 150, 105, 0.2); color: #10b981; }
        .badge-hold { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
        .badge-sell { background: rgba(220, 38, 38, 0.2); color: #f87171; }
        
        /* Grid */
        .grid-auto-fit {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
        }
    </style>
</head>
<body class="antialiased min-h-screen flex flex-col font-sans bg-dark-950">

    <!-- Global Market Context -->
    <div id="global-context" class="glass border-b border-gray-800">
        <div class="max-w-[1800px] mx-auto px-4 py-3">
            <div class="flex flex-wrap gap-4 items-center justify-between">
                <div class="flex items-center gap-6">
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-gray-500">BTC Dominance:</span>
                        <span id="btc-dominance" class="text-sm font-bold text-white">--%</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-gray-500">Fear & Greed:</span>
                        <span id="fear-greed" class="text-sm font-bold">--</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-gray-500">Total Market Cap:</span>
                        <span id="total-marketcap" class="text-sm font-bold text-white">--</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-gray-500">Market Sentiment:</span>
                        <span id="market-sentiment" class="text-sm font-bold">--</span>
                    </div>
                </div>
                <div class="text-xs text-gray-500">
                    Last Update: <span id="global-update-time">--:--:--</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Header -->
    <header class="glass sticky top-0 z-50 border-b border-gray-800">
        <div class="max-w-[1800px] mx-auto px-4 h-16 flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-gradient-to-br from-brand-600 to-indigo-800 rounded-lg flex items-center justify-center">
                    <i class="fa-solid fa-holder text-white"></i>
                </div>
                <div>
                    <h1 class="font-bold text-xl text-white">CryptoPanel<span class="text-brand-500">HOLDER</span> <span class="text-xs text-gray-500 border border-gray-700 rounded px-1 ml-1">v13</span></h1>
                    <div class="text-xs text-gray-400 font-mono">LONG TERM • QUANTITATIVE • FUNDAMENTAL</div>
                </div>
            </div>
            
            <div class="flex items-center gap-2">
                <input id="searchToken" type="text" placeholder="Buscar token..." class="bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-sm text-white focus:border-brand-500 outline-none w-40">
                <button id="refreshData" class="p-2 bg-brand-600 hover:bg-brand-500 rounded-lg text-white">
                    <i class="fa-solid fa-rotate"></i>
                </button>
                <button onclick="App.Settings.openModal()" class="p-2 bg-dark-800 border border-gray-700 rounded-lg">
                    <i class="fa-solid fa-gear"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 max-w-[1800px] mx-auto px-4 py-6">
        
        <!-- Stats Overview -->
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
            <div class="glass rounded-lg p-4">
                <div class="text-xs text-gray-500 mb-1">Tokens Monitorados</div>
                <div id="stats-tokens" class="text-2xl font-bold text-white">0</div>
            </div>
            <div class="glass rounded-lg p-4">
                <div class="text-xs text-gray-500 mb-1">Oportunidades Fortes</div>
                <div id="stats-opportunities" class="text-2xl font-bold text-score-high">0</div>
            </div>
            <div class="glass rounded-lg p-4">
                <div class="text-xs text-gray-500 mb-1">Risco Elevado</div>
                <div id="stats-risks" class="text-2xl font-bold text-score-low">0</div>
            </div>
            <div class="glass rounded-lg p-4">
                <div class="text-xs text-gray-500 mb-1">Assimetria Média</div>
                <div id="stats-asymmetry" class="text-2xl font-bold text-white">0.0x</div>
            </div>
        </div>

        <!-- Main Ranking -->
        <div class="glass rounded-xl overflow-hidden border border-gray-800 mb-6">
            <div class="bg-dark-800/80 p-4 border-b border-gray-700">
                <div class="flex justify-between items-center">
                    <h2 class="text-white font-bold text-lg"><i class="fa-solid fa-ranking-star text-brand-500 mr-2"></i>Ranking de Oportunidades Holder</h2>
                    <div class="text-xs text-gray-500">
                        Score > 70: Oportunidade Forte • 40-70: Neutro • < 40: Risco
                    </div>
                </div>
            </div>
            
            <div class="overflow-x-auto">
                <table class="w-full text-sm">
                    <thead class="text-gray-400 uppercase text-xs border-b border-gray-800">
                        <tr>
                            <th class="p-3 text-center">#</th>
                            <th class="p-3 text-left">Token</th>
                            <th class="p-3 text-center">Score</th>
                            <th class="p-3 text-center">RSI 1D</th>
                            <th class="p-3 text-center mobile-hide">Volatilidade</th>
                            <th class="p-3 text-center mobile-hide">Market Cap</th>
                            <th class="p-3 text-center">Assimetria</th>
                            <th class="p-3 text-center">ATH Dist.</th>
                            <th class="p-3 text-center">Ação</th>
                        </tr>
                    </thead>
                    <tbody id="ranking-body" class="text-gray-300">
                        <tr><td colspan="9" class="p-8 text-center"><div class="loading-pulse">Carregando dados...</div></td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Token Cards Grid -->
        <div id="cards-container" class="mb-6">
            <h3 class="text-white font-bold mb-4">Tokens Monitorados</h3>
            <div id="cards-grid" class="grid-auto-fit gap-4"></div>
        </div>

        <!-- Analysis Panel -->
        <div id="analysis-panel" class="glass rounded-xl border border-gray-800 p-6 mb-6 hidden">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-white font-bold" id="analysis-title">Análise Detalhada</h3>
                <button onclick="App.UI.closeAnalysis()" class="text-gray-500 hover:text-white">
                    <i class="fa-solid fa-times"></i>
                </button>
            </div>
            <div id="analysis-content"></div>
        </div>

        <!-- Add Token -->
        <div class="glass rounded-lg p-4 mb-6">
            <div class="flex gap-2">
                <input id="add-token-input" type="text" placeholder="Adicionar token (ex: BTC, ETH)..." class="flex-1 bg-dark-800 border border-gray-700 rounded-lg px-4 py-2 text-white focus:border-brand-500 outline-none">
                <button onclick="App.Token.add()" class="bg-brand-600 hover:bg-brand-500 text-white px-4 py-2 rounded-lg">
                    <i class="fa-solid fa-plus"></i> Adicionar
                </button>
            </div>
        </div>

    </main>

    <!-- Tooltip Overlay -->
    <div id="metric-tooltip" class="metric-tooltip tooltip-hidden"></div>

    <!-- Modals -->
    <div id="settings-modal" class="fixed inset-0 z-50 hidden items-center justify-center p-4 bg-black/80">
        <div class="glass rounded-xl w-full max-w-2xl max-h-[80vh] overflow-hidden">
            <div class="p-4 border-b border-gray-700 flex justify-between items-center">
                <h3 class="text-white font-bold">Configurações</h3>
                <button onclick="App.Settings.closeModal()" class="text-gray-500 hover:text-white">
                    <i class="fa-solid fa-times"></i>
                </button>
            </div>
            <div class="p-6 overflow-y-auto">
                <div id="settings-content"></div>
            </div>
        </div>
    </div>

    <!-- Card Template -->
    <template id="card-template">
        <div class="glass rounded-xl overflow-hidden flex flex-col h-full">
            <div class="p-4 border-b border-gray-800 flex justify-between items-center">
                <div class="flex items-center gap-3">
                    <div class="score-badge w-10 h-10 rounded-full flex items-center justify-center font-bold text-white"></div>
                    <div>
                        <h4 class="font-bold text-white symbol-ticker"></h4>
                        <div class="text-xs text-gray-500 price-display"></div>
                    </div>
                </div>
                <button class="remove-token text-gray-500 hover:text-red-500">
                    <i class="fa-solid fa-times"></i>
                </button>
            </div>
            
            <div class="p-4 space-y-4">
                <!-- Key Metrics -->
                <div class="grid grid-cols-2 gap-3">
                    <div class="metric-item">
                        <div class="text-xs text-gray-500">Score Holder</div>
                        <div class="text-lg font-bold score-value"></div>
                    </div>
                    <div class="metric-item">
                        <div class="text-xs text-gray-500">Assimetria</div>
                        <div class="text-lg font-bold asymmetry-value"></div>
                    </div>
                </div>
                
                <!-- Progress Bars -->
                <div class="space-y-2">
                    <div>
                        <div class="text-xs text-gray-500 mb-1">Potencial de Alta</div>
                        <div class="progress-bar">
                            <div class="progress-fill bg-green-500 upside-potential"></div>
                        </div>
                    </div>
                    <div>
                        <div class="text-xs text-gray-500 mb-1">Risco de Baixa</div>
                        <div class="progress-bar">
                            <div class="progress-fill bg-red-500 downside-risk"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Quick Stats -->
                <div class="grid grid-cols-2 gap-2 text-xs">
                    <div class="flex justify-between">
                        <span class="text-gray-500">Market Cap:</span>
                        <span class="text-white market-cap"></span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-500">Vol 30d:</span>
                        <span class="text-white volatility"></span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-500">RSI 1D:</span>
                        <span class="text-white rsi-1d"></span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-500">ATH Dist:</span>
                        <span class="text-white ath-distance"></span>
                    </div>
                </div>
                
                <!-- Action Button -->
                <button class="w-full mt-2 action-button rounded-lg py-2 text-sm font-bold text-white">
                    Ver Análise Completa
                </button>
            </div>
        </div>
    </template>

    <!-- Analysis Template -->
    <template id="analysis-template">
        <div class="space-y-6">
            <!-- Header -->
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="score-badge-large w-12 h-12 rounded-full flex items-center justify-center font-bold text-white text-lg"></div>
                    <div>
                        <h4 class="font-bold text-xl symbol-ticker"></h4>
                        <div class="text-sm text-gray-400 price-display"></div>
                    </div>
                </div>
                <div class="recommendation-badge badge"></div>
            </div>
            
            <!-- Score Breakdown -->
            <div>
                <h5 class="text-white font-bold mb-3">Composição do Score Holder</h5>
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <span class="text-sm text-gray-400">RSI 1D & 1W</span>
                        <div class="flex items-center gap-2">
                            <div class="progress-bar w-32">
                                <div class="progress-fill bg-blue-500" style="width: 0%"></div>
                            </div>
                            <span class="text-sm font-bold">0/20</span>
                        </div>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-sm text-gray-400">Suporte & Fibonacci</span>
                        <div class="flex items-center gap-2">
                            <div class="progress-bar w-32">
                                <div class="progress-fill bg-blue-500" style="width: 0%"></div>
                            </div>
                            <span class="text-sm font-bold">0/20</span>
                        </div>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-sm text-gray-400">Market Cap & Volume</span>
                        <div class="flex items-center gap-2">
                            <div class="progress-bar w-32">
                                <div class="progress-fill bg-blue-500" style="width: 0%"></div>
                            </div>
                            <span class="text-sm font-bold">0/20</span>
                        </div>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-sm text-gray-400">Volatilidade & Tendência</span>
                        <div class="flex items-center gap-2">
                            <div class="progress-bar w-32">
                                <div class="progress-fill bg-blue-500" style="width: 0%"></div>
                            </div>
                            <span class="text-sm font-bold">0/20</span>
                        </div>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-sm text-gray-400">Assimetria (R:R)</span>
                        <div class="flex items-center gap-2">
                            <div class="progress-bar w-32">
                                <div class="progress-fill bg-blue-500" style="width: 0%"></div>
                            </div>
                            <span class="text-sm font-bold">0/20</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Detailed Metrics -->
            <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                <div class="metric-card">
                    <div class="text-xs text-gray-500">Market Cap</div>
                    <div class="text-lg font-bold market-cap"></div>
                    <div class="text-xs market-cap-rank"></div>
                </div>
                <div class="metric-card">
                    <div class="text-xs text-gray-500">Volume 24h</div>
                    <div class="text-lg font-bold volume-24h"></div>
                    <div class="text-xs volume-ratio"></div>
                </div>
                <div class="metric-card">
                    <div class="text-xs text-gray-500">Volatilidade 30d</div>
                    <div class="text-lg font-bold volatility-30d"></div>
                    <div class="text-xs volatility-status"></div>
                </div>
                <div class="metric-card">
                    <div class="text-xs text-gray-500">ATH Distance</div>
                    <div class="text-lg font-bold ath-distance"></div>
                    <div class="text-xs ath-status"></div>
                </div>
                <div class="metric-card">
                    <div class="text-xs text-gray-500">SMA50 / SMA200</div>
                    <div class="text-lg font-bold sma-ratio"></div>
                    <div class="text-xs sma-status"></div>
                </div>
                <div class="metric-card">
                    <div class="text-xs text-gray-500">Assimetria (R:R)</div>
                    <div class="text-lg font-bold asymmetry-value"></div>
                    <div class="text-xs asymmetry-status"></div>
                </div>
            </div>
            
            <!-- Chart -->
            <div>
                <h5 class="text-white font-bold mb-3">Performance Long-Term</h5>
                <div class="chart-container" style="height: 300px;"></div>
            </div>
            
            <!-- Analysis Text -->
            <div id="analysis-text" class="text-sm text-gray-300 leading-relaxed"></div>
        </div>
    </template>

    <!-- JavaScript Application -->
    <script>
        // ============================================================================
        // CORE APPLICATION - MODULAR ARCHITECTURE FOR HOLDER SYSTEM
        // ============================================================================

        const App = {
            
            // ============================================================================
            // 1. STATE MANAGEMENT
            // ============================================================================
            State: {
                // Tokens being monitored
                tokens: JSON.parse(localStorage.getItem('holder_tokens_v13')) || ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT'],
                
                // Timeframes for holders (4h, 1D, 1W only)
                timeframes: ['4h', '1D', '1W'],
                
                // Data storage
                marketData: {},        // Current market prices, volume, etc.
                ohlcData: {},          // OHLC data by timeframe
                indicatorsData: {},     // Technical indicators
                fundamentalData: {},   // Market cap, volume ratio, etc.
                scoreData: {},         // Holder scores and components
                
                // Global market context
                globalContext: {
                    btcDominance: null,
                    fearGreedIndex: null,
                    totalMarketCap: null,
                    totalVolume: null,
                    marketSentiment: null,
                    lastUpdate: null
                },
                
                // Settings
                settings: JSON.parse(localStorage.getItem('holder_settings_v13')) || {
                    autoRefresh: true,
                    refreshInterval: 300, // 5 minutes for holders
                    showVolatility: true,
                    showMarketCap: true,
                    showAsymmetry: true
                },
                
                // WebSocket connection
                ws: null,
                
                // Cache control
                lastUpdate: Date.now(),
                updateInterval: null
            },

            // ============================================================================
            // 2. MARKET PROVIDERS MODULE
            // ============================================================================
            Providers: {
                // Binance REST API
                Binance: {
                    baseURL: 'https://api.binance.com/api/v3',
                    
                    async getPrice(symbol) {
                        try {
                            const response = await fetch(`${this.baseURL}/ticker/price?symbol=${symbol}`);
                            return await response.json();
                        } catch (error) {
                            console.error('Binance price error:', error);
                            return null;
                        }
                    },
                    
                    async get24hStats(symbol) {
                        try {
                            const response = await fetch(`${this.baseURL}/ticker/24hr?symbol=${symbol}`);
                            return await response.json();
                        } catch (error) {
                            console.error('Binance 24h stats error:', error);
                            return null;
                        }
                    },
                    
                    async getKLines(symbol, interval, limit = 100) {
                        try {
                            const response = await fetch(
                                `${this.baseURL}/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`
                            );
                            return await response.json();
                        } catch (error) {
                            console.error('Binance KLines error:', error);
                            return [];
                        }
                    }
                },
                
                // CoinGecko Premium (via proxy for security)
                CoinGecko: {
                    proxyURL: '/api/coingecko', // Should be implemented server-side
                    
                    async getCoinData(coinId) {
                        try {
                            const response = await fetch(`${this.proxyURL}/coins/${coinId}`);
                            return await response.json();
                        } catch (error) {
                            console.error('CoinGecko error:', error);
                            return null;
                        }
                    },
                    
                    async getGlobalData() {
                        try {
                            const response = await fetch(`${this.proxyURL}/global`);
                            return await response.json();
                        } catch (error) {
                            console.error('CoinGecko global error:', error);
                            return null;
                        }
                    }
                },
                
                // Fear & Greed Index
                FearGreed: {
                    async getIndex() {
                        try {
                            // Using alternative API since the original requires API key
                            const response = await fetch('https://api.alternative.me/fng/');
                            const data = await response.json();
                            return data.data[0];
                        } catch (error) {
                            console.error('Fear & Greed error:', error);
                            return { value: '50', value_classification: 'Neutral' };
                        }
                    }
                }
            },

            // ============================================================================
            // 3. OHLC DATA MODULE (Optimized for Holders)
            // ============================================================================
            OHLC: {
                // Load OHLC data for a specific symbol and timeframe
                async load(symbol, timeframe) {
                    const cacheKey = `${symbol}_${timeframe}`;
                    const cached = localStorage.getItem(cacheKey);
                    
                    if (cached && (Date.now() - JSON.parse(cached).timestamp < 300000)) {
                        // Use cached data if less than 5 minutes old
                        return JSON.parse(cached).data;
                    }
                    
                    // Fetch new data
                    const data = await this.fetch(symbol, timeframe);
                    
                    // Cache the data
                    if (data.length > 0) {
                        localStorage.setItem(cacheKey, JSON.stringify({
                            timestamp: Date.now(),
                            data: data
                        }));
                    }
                    
                    return data;
                },
                
                // Fetch data from Binance
                async fetch(symbol, interval) {
                    try {
                        const klines = await App.Providers.Binance.getKLines(symbol, interval, 200);
                        return klines.map(k => ({
                            time: k[0],
                            open: parseFloat(k[1]),
                            high: parseFloat(k[2]),
                            low: parseFloat(k[3]),
                            close: parseFloat(k[4]),
                            volume: parseFloat(k[5])
                        }));
                    } catch (error) {
                        console.error(`OHLC fetch error for ${symbol} ${interval}:`, error);
                        return [];
                    }
                },
                
                // Incremental update (only for active symbols)
                async update(symbol) {
                    for (const tf of App.State.timeframes) {
                        const newData = await this.fetch(symbol, tf, 2); // Only last 2 candles
                        const existingData = App.State.ohlcData[symbol]?.[tf] || [];
                        
                        if (newData.length > 0) {
                            // Merge and update
                            App.State.ohlcData[symbol] = App.State.ohlcData[symbol] || {};
                            App.State.ohlcData[symbol][tf] = [
                                ...existingData.slice(0, -1),
                                ...newData
                            ].slice(-200); // Keep only last 200
                        }
                    }
                }
            },

            // ============================================================================
            // 4. HOLDER ENGINE MODULE (Quantitative Analysis)
            // ============================================================================
            HolderEngine: {
                
                // ------------------------------------------------------------------------
                // 4.1. TECHNICAL INDICATORS
                // ------------------------------------------------------------------------
                Indicators: {
                    // RSI Calculation (14 period)
                    calculateRSI(closes, period = 14) {
                        if (closes.length < period + 1) return null;
                        
                        let gains = [];
                        let losses = [];
                        
                        for (let i = 1; i < closes.length; i++) {
                            const change = closes[i] - closes[i - 1];
                            gains.push(change > 0 ? change : 0);
                            losses.push(change < 0 ? -change : 0);
                        }
                        
                        // Calculate average gains and losses
                        let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
                        let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
                        
                        for (let i = period; i < gains.length; i++) {
                            avgGain = (avgGain * (period - 1) + gains[i]) / period;
                            avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
                        }
                        
                        if (avgLoss === 0) return 100;
                        const rs = avgGain / avgLoss;
                        return 100 - (100 / (1 + rs));
                    },
                    
                    // SMA Calculation
                    calculateSMA(closes, period) {
                        if (closes.length < period) return null;
                        return closes.slice(-period).reduce((a, b) => a + b, 0) / period;
                    },
                    
                    // Volatility (Standard Deviation of returns)
                    calculateVolatility(closes, period = 30) {
                        if (closes.length < period) return null;
                        
                        const recentCloses = closes.slice(-period);
                        const returns = [];
                        
                        for (let i = 1; i < recentCloses.length; i++) {
                            returns.push((recentCloses[i] - recentCloses[i-1]) / recentCloses[i-1]);
                        }
                        
                        const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
                        const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
                        
                        return Math.sqrt(variance) * 100; // Return as percentage
                    },
                    
                    // ATR (Average True Range)
                    calculateATR(ohlc, period = 14) {
                        if (ohlc.length < period) return null;
                        
                        const trueRanges = [];
                        for (let i = 1; i < ohlc.length; i++) {
                            const tr = Math.max(
                                ohlc[i].high - ohlc[i].low,
                                Math.abs(ohlc[i].high - ohlc[i-1].close),
                                Math.abs(ohlc[i].low - ohlc[i-1].close)
                            );
                            trueRanges.push(tr);
                        }
                        
                        // Simple moving average of true ranges
                        return this.calculateSMA(trueRanges, period);
                    }
                },
                
                // ------------------------------------------------------------------------
                // 4.2. FIBONACCI ANALYSIS
                // ------------------------------------------------------------------------
                Fibonacci: {
                    calculateLevels(high, low) {
                        const range = high - low;
                        return {
                            f0382: high - 0.382 * range,
                            f0500: high - 0.500 * range,
                            f0618: high - 0.618 * range,  // Primary buy zone
                            f0786: high - 0.786 * range,  // Deep buy zone
                            f1272: low + 1.272 * range,   // Primary take profit
                            f1618: low + 1.618 * range    // Aggressive take profit
                        };
                    },
                    
                    getNearestLevel(currentPrice, levels) {
                        const levelDistances = [
                            { level: 'f0618', price: levels.f0618, distance: Math.abs(currentPrice - levels.f0618) },
                            { level: 'f0786', price: levels.f0786, distance: Math.abs(currentPrice - levels.f0786) },
                            { level: 'f1272', price: levels.f1272, distance: Math.abs(currentPrice - levels.f1272) },
                            { level: 'f1618', price: levels.f1618, distance: Math.abs(currentPrice - levels.f1618) }
                        ];
                        
                        levelDistances.sort((a, b) => a.distance - b.distance);
                        return levelDistances[0];
                    }
                },
                
                // ------------------------------------------------------------------------
                // 4.3. ASYMMETRY CALCULATION (Risk/Reward Ratio)
                // ------------------------------------------------------------------------
                Asymmetry: {
                    calculate(currentPrice, supportPrice, resistancePrice) {
                        if (!supportPrice || !resistancePrice || supportPrice <= 0) {
                            return 1.0; // Neutral if data missing
                        }
                        
                        const upsidePotential = (resistancePrice - currentPrice) / currentPrice;
                        const downsideRisk = (currentPrice - supportPrice) / currentPrice;
                        
                        // Avoid division by zero or negative values
                        if (downsideRisk <= 0) return 10.0; // Extremely favorable
                        
                        const asymmetry = upsidePotential / downsideRisk;
                        
                        // Cap at 10.0 for display purposes
                        return Math.min(asymmetry, 10.0);
                    },
                    
                    getInterpretation(asymmetry) {
                        if (asymmetry >= 3.0) return { text: 'Excelente', color: 'text-green-500', class: 'bg-green-500/10' };
                        if (asymmetry >= 2.0) return { text: 'Boa', color: 'text-blue-500', class: 'bg-blue-500/10' };
                        if (asymmetry >= 1.0) return { text: 'Neutra', color: 'text-yellow-500', class: 'bg-yellow-500/10' };
                        return { text: 'Risco', color: 'text-red-500', class: 'bg-red-500/10' };
                    }
                },
                
                // ------------------------------------------------------------------------
                // 4.4. HOLDER SCORE CALCULATION (Quantitative Model)
                // ------------------------------------------------------------------------
                Score: {
                    calculate(tokenData) {
                        let totalScore = 0;
                        const componentScores = {};
                        
                        // 1. RSI Component (20% weight)
                        const rsiScore = this.calculateRSIScore(tokenData.rsi1D, tokenData.rsi1W);
                        componentScores.rsi = rsiScore;
                        totalScore += rsiScore * 0.2;
                        
                        // 2. Support & Fibonacci (20% weight)
                        const supportScore = this.calculateSupportScore(tokenData);
                        componentScores.support = supportScore;
                        totalScore += supportScore * 0.2;
                        
                        // 3. Market Cap & Volume (20% weight)
                        const marketScore = this.calculateMarketScore(tokenData);
                        componentScores.market = marketScore;
                        totalScore += marketScore * 0.2;
                        
                        // 4. Volatility & Trend (20% weight)
                        const volatilityScore = this.calculateVolatilityScore(tokenData);
                        componentScores.volatility = volatilityScore;
                        totalScore += volatilityScore * 0.2;
                        
                        // 5. Asymmetry (20% weight)
                        const asymmetryScore = this.calculateAsymmetryScore(tokenData.asymmetry);
                        componentScores.asymmetry = asymmetryScore;
                        totalScore += asymmetryScore * 0.2;
                        
                        // Apply global market context adjustment
                        totalScore = this.applyGlobalAdjustment(totalScore);
                        
                        // Clamp between 0 and 100
                        totalScore = Math.max(0, Math.min(100, totalScore));
                        
                        return {
                            total: Math.round(totalScore),
                            components: componentScores,
                            recommendation: this.getRecommendation(totalScore)
                        };
                    },
                    
                    calculateRSIScore(rsi1D, rsi1W) {
                        let score = 50;
                        
                        if (rsi1D < 30) score += 25;
                        else if (rsi1D < 40) score += 15;
                        else if (rsi1D > 70) score -= 25;
                        else if (rsi1D > 60) score -= 15;
                        
                        if (rsi1W < 40) score += 15;
                        else if (rsi1W > 60) score -= 15;
                        
                        return Math.max(0, Math.min(100, score));
                    },
                    
                    calculateSupportScore(tokenData) {
                        let score = 50;
                        
                        // Distance to support
                        if (tokenData.supportDistance < 5) score += 20;
                        else if (tokenData.supportDistance < 10) score += 10;
                        else if (tokenData.supportDistance > 20) score -= 15;
                        
                        // Fibonacci proximity
                        if (tokenData.fibDistance < 2) score += 15;
                        else if (tokenData.fibDistance < 5) score += 10;
                        
                        return Math.max(0, Math.min(100, score));
                    },
                    
                    calculateMarketScore(tokenData) {
                        let score = 50;
                        
                        // Market Cap Rank (lower is better)
                        if (tokenData.marketCapRank < 10) score += 20;
                        else if (tokenData.marketCapRank < 50) score += 15;
                        else if (tokenData.marketCapRank < 100) score += 10;
                        else if (tokenData.marketCapRank > 200) score -= 10;
                        
                        // Volume/MarketCap Ratio
                        if (tokenData.volumeRatio > 0.05) score += 10;
                        else if (tokenData.volumeRatio < 0.01) score -= 10;
                        
                        return Math.max(0, Math.min(100, score));
                    },
                    
                    calculateVolatilityScore(tokenData) {
                        let score = 50;
                        
                        // Lower volatility is better for holders
                        if (tokenData.volatility30d < 20) score += 20;
                        else if (tokenData.volatility30d < 40) score += 10;
                        else if (tokenData.volatility30d > 80) score -= 20;
                        else if (tokenData.volatility30d > 60) score -= 10;
                        
                        // Trend alignment
                        if (tokenData.trendAlignment > 0.7) score += 10;
                        else if (tokenData.trendAlignment < 0.3) score -= 10;
                        
                        return Math.max(0, Math.min(100, score));
                    },
                    
                    calculateAsymmetryScore(asymmetry) {
                        // Convert asymmetry ratio to 0-100 score
                        if (asymmetry >= 3.0) return 90;
                        if (asymmetry >= 2.0) return 70;
                        if (asymmetry >= 1.0) return 50;
                        if (asymmetry >= 0.5) return 30;
                        return 10;
                    },
                    
                    applyGlobalAdjustment(score) {
                        // Adjust based on global market conditions
                        const context = App.State.globalContext;
                        
                        if (context.marketSentiment === 'bearish') {
                            return score * 0.9; // Reduce scores in bear markets
                        } else if (context.marketSentiment === 'bullish') {
                            return score * 1.1; // Increase scores in bull markets
                        }
                        
                        return score;
                    },
                    
                    getRecommendation(score) {
                        if (score >= 70) return { 
                            action: 'COMPRAR', 
                            color: 'text-green-500', 
                            badge: 'badge-buy',
                            explanation: 'Oportunidade forte de acumulação' 
                        };
                        if (score >= 40) return { 
                            action: 'ACOMPANHAR', 
                            color: 'text-blue-500', 
                            badge: 'badge-hold',
                            explanation: 'Situação neutra, aguardar oportunidade' 
                        };
                        return { 
                            action: 'CUIDADO', 
                            color: 'text-red-500', 
                            badge: 'badge-sell',
                            explanation: 'Risco elevado, considere realizar lucros' 
                        };
                    }
                },
                
                // ------------------------------------------------------------------------
                // 4.5. TREND ANALYSIS
                // ------------------------------------------------------------------------
                Trend: {
                    analyzeTrend(closes) {
                        if (closes.length < 50) return { direction: 'neutral', strength: 0 };
                        
                        const sma20 = App.HolderEngine.Indicators.calculateSMA(closes, 20);
                        const sma50 = App.HolderEngine.Indicators.calculateSMA(closes, 50);
                        const sma200 = App.HolderEngine.Indicators.calculateSMA(closes, 200);
                        const currentPrice = closes[closes.length - 1];
                        
                        // Determine trend direction
                        let bullishSignals = 0;
                        let bearishSignals = 0;
                        
                        if (currentPrice > sma20) bullishSignals++;
                        else bearishSignals++;
                        
                        if (sma20 > sma50) bullishSignals++;
                        else bearishSignals++;
                        
                        if (sma50 > sma200) bullishSignals++;
                        else bearishSignals++;
                        
                        const direction = bullishSignals > bearishSignals ? 'bullish' : 
                                        bearishSignals > bullishSignals ? 'bearish' : 'neutral';
                        
                        // Calculate trend strength (0 to 1)
                        const strength = bullishSignals / 3;
                        
                        return { direction, strength };
                    },
                    
                    getTrend30_90_180(closes) {
                        if (closes.length < 180) return { trend30: 'neutral', trend90: 'neutral', trend180: 'neutral' };
                        
                        const recent30 = closes.slice(-30);
                        const recent90 = closes.slice(-90);
                        const recent180 = closes.slice(-180);
                        
                        const calcTrend = (prices) => {
                            const first = prices[0];
                            const last = prices[prices.length - 1];
                            const change = ((last - first) / first) * 100;
                            
                            if (change > 10) return 'strong_bullish';
                            if (change > 5) return 'bullish';
                            if (change < -10) return 'strong_bearish';
                            if (change < -5) return 'bearish';
                            return 'neutral';
                        };
                        
                        return {
                            trend30: calcTrend(recent30),
                            trend90: calcTrend(recent90),
                            trend180: calcTrend(recent180)
                        };
                    }
                }
            },

            // ============================================================================
            // 5. GLOBAL MARKET CONTEXT ENGINE
            // ============================================================================
            GlobalContext: {
                async update() {
                    try {
                        // Update Fear & Greed Index
                        const fng = await App.Providers.FearGreed.getIndex();
                        App.State.globalContext.fearGreedIndex = fng.value;
                        App.State.globalContext.marketSentiment = this.getSentiment(fng.value);
                        
                        // Update global stats from CoinGecko (via proxy)
                        const globalData = await App.Providers.CoinGecko.getGlobalData();
                        if (globalData) {
                            App.State.globalContext.totalMarketCap = globalData.data.total_market_cap.usd;
                            App.State.globalContext.totalVolume = globalData.data.total_volume.usd;
                            App.State.globalContext.btcDominance = globalData.data.market_cap_percentage.btc;
                        }
                        
                        App.State.globalContext.lastUpdate = new Date().toLocaleTimeString();
                        
                        // Update UI
                        this.updateUI();
                        
                    } catch (error) {
                        console.error('Global context update error:', error);
                    }
                },
                
                getSentiment(value) {
                    const numValue = parseInt(value);
                    if (numValue >= 75) return 'extreme_greed';
                    if (numValue >= 60) return 'greed';
                    if (numValue >= 45) return 'neutral';
                    if (numValue >= 30) return 'fear';
                    return 'extreme_fear';
                },
                
                updateUI() {
                    const ctx = App.State.globalContext;
                    
                    // Update BTC Dominance
                    if (ctx.btcDominance) {
                        document.getElementById('btc-dominance').textContent = `${ctx.btcDominance.toFixed(1)}%`;
                    }
                    
                    // Update Fear & Greed
                    if (ctx.fearGreedIndex) {
                        const fngEl = document.getElementById('fear-greed');
                        fngEl.textContent = ctx.fearGreedIndex;
                        
                        // Color coding
                        const numValue = parseInt(ctx.fearGreedIndex);
                        if (numValue >= 75) fngEl.className = 'text-sm font-bold text-red-500';
                        else if (numValue >= 60) fngEl.className = 'text-sm font-bold text-yellow-500';
                        else if (numValue >= 45) fngEl.className = 'text-sm font-bold text-green-500';
                        else if (numValue >= 30) fngEl.className = 'text-sm font-bold text-blue-500';
                        else fngEl.className = 'text-sm font-bold text-purple-500';
                    }
                    
                    // Update Market Cap
                    if (ctx.totalMarketCap) {
                        const marketCap = ctx.totalMarketCap;
                        let display = '';
                        
                        if (marketCap >= 1e12) display = `$${(marketCap / 1e12).toFixed(2)}T`;
                        else if (marketCap >= 1e9) display = `$${(marketCap / 1e9).toFixed(2)}B`;
                        else display = `$${(marketCap / 1e6).toFixed(2)}M`;
                        
                        document.getElementById('total-marketcap').textContent = display;
                    }
                    
                    // Update Market Sentiment
                    if (ctx.marketSentiment) {
                        const sentimentEl = document.getElementById('market-sentiment');
                        sentimentEl.textContent = ctx.marketSentiment.replace('_', ' ').toUpperCase();
                        
                        // Color coding
                        switch(ctx.marketSentiment) {
                            case 'extreme_greed': sentimentEl.className = 'text-sm font-bold text-red-500'; break;
                            case 'greed': sentimentEl.className = 'text-sm font-bold text-yellow-500'; break;
                            case 'neutral': sentimentEl.className = 'text-sm font-bold text-green-500'; break;
                            case 'fear': sentimentEl.className = 'text-sm font-bold text-blue-500'; break;
                            case 'extreme_fear': sentimentEl.className = 'text-sm font-bold text-purple-500'; break;
                        }
                    }
                    
                    // Update time
                    document.getElementById('global-update-time').textContent = ctx.lastUpdate || '--:--:--';
                }
            },

            // ============================================================================
            // 6. TOKEN MANAGEMENT
            // ============================================================================
            Token: {
                async add() {
                    const input = document.getElementById('add-token-input');
                    let symbol = input.value.trim().toUpperCase();
                    
                    if (!symbol) {
                        alert('Digite um símbolo de token');
                        return;
                    }
                    
                    // Add USDT if not present
                    if (!symbol.endsWith('USDT')) {
                        symbol += 'USDT';
                    }
                    
                    // Check if already exists
                    if (App.State.tokens.includes(symbol)) {
                        alert('Token já está na lista');
                        return;
                    }
                    
                    // Validate token exists
                    try {
                        const priceData = await App.Providers.Binance.getPrice(symbol);
                        if (!priceData || priceData.code) {
                            alert('Token não encontrado na Binance');
                            return;
                        }
                        
                        // Add to list
                        App.State.tokens.push(symbol);
                        localStorage.setItem('holder_tokens_v13', JSON.stringify(App.State.tokens));
                        
                        // Clear input
                        input.value = '';
                        
                        // Reload data for this token
                        await App.Core.loadTokenData(symbol);
                        
                        // Update UI
                        App.UI.renderCards();
                        App.UI.renderRanking();
                        
                    } catch (error) {
                        console.error('Token validation error:', error);
                        alert('Erro ao validar token');
                    }
                },
                
                async remove(symbol) {
                    App.State.tokens = App.State.tokens.filter(t => t !== symbol);
                    localStorage.setItem('holder_tokens_v13', JSON.stringify(App.State.tokens));
                    
                    // Clean up data
                    delete App.State.marketData[symbol.toLowerCase()];
                    delete App.State.ohlcData[symbol];
                    delete App.State.indicatorsData[symbol];
                    delete App.State.fundamentalData[symbol];
                    delete App.State.scoreData[symbol];
                    
                    // Update UI
                    App.UI.renderCards();
                    App.UI.renderRanking();
                },
                
                async loadAllTokens() {
                    const promises = App.State.tokens.map(symbol => 
                        App.Core.loadTokenData(symbol)
                    );
                    
                    await Promise.all(promises);
                }
            },

            // ============================================================================
            // 7. CORE ENGINE (Orchestration)
            // ============================================================================
            Core: {
                async init() {
                    console.log('🚀 Initializing CryptoPanelPRO HOLDER v13...');
                    
                    // Initialize global context
                    await App.GlobalContext.update();
                    
                    // Load all token data
                    await App.Token.loadAllTokens();
                    
                    // Initialize WebSocket for real-time updates
                    this.initWebSocket();
                    
                    // Initial UI render
                    App.UI.renderCards();
                    App.UI.renderRanking();
                    App.UI.updateStats();
                    
                    // Set up periodic updates
                    this.setupPeriodicUpdates();
                    
                    // Initialize tooltips
                    this.initTooltips();
                    
                    console.log('✅ CryptoPanelPRO HOLDER v13 initialized');
                },
                
                async loadTokenData(symbol) {
                    try {
                        const symbolLower = symbol.toLowerCase();
                        
                        // 1. Load market data
                        const stats24h = await App.Providers.Binance.get24hStats(symbol);
                        if (stats24h) {
                            App.State.marketData[symbolLower] = {
                                symbol: symbol,
                                price: parseFloat(stats24h.lastPrice),
                                change24h: parseFloat(stats24h.priceChangePercent),
                                high24h: parseFloat(stats24h.highPrice),
                                low24h: parseFloat(stats24h.lowPrice),
                                volume24h: parseFloat(stats24h.volume),
                                quoteVolume: parseFloat(stats24h.quoteVolume)
                            };
                        }
                        
                        // 2. Load OHLC data for holder timeframes
                        for (const timeframe of App.State.timeframes) {
                            const ohlc = await App.OHLC.load(symbol, timeframe);
                            if (ohlc.length > 0) {
                                App.State.ohlcData[symbol] = App.State.ohlcData[symbol] || {};
                                App.State.ohlcData[symbol][timeframe] = ohlc;
                            }
                        }
                        
                        // 3. Calculate indicators
                        await this.calculateIndicators(symbol);
                        
                        // 4. Calculate holder score
                        this.calculateHolderScore(symbol);
                        
                    } catch (error) {
                        console.error(`Error loading data for ${symbol}:`, error);
                    }
                },
                
                async calculateIndicators(symbol) {
                    const symbolLower = symbol.toLowerCase();
                    App.State.indicatorsData[symbol] = App.State.indicatorsData[symbol] || {};
                    
                    // Get OHLC data
                    const ohlc1D = App.State.ohlcData[symbol]?.['1D'] || [];
                    const ohlc1W = App.State.ohlcData[symbol]?.['1W'] || [];
                    
                    if (ohlc1D.length === 0 || ohlc1W.length === 0) return;
                    
                    // Extract closing prices
                    const closes1D = ohlc1D.map(c => c.close);
                    const closes1W = ohlc1W.map(c => c.close);
                    
                    // Calculate indicators
                    const indicators = {};
                    
                    // RSI
                    indicators.rsi1D = App.HolderEngine.Indicators.calculateRSI(closes1D);
                    indicators.rsi1W = App.HolderEngine.Indicators.calculateRSI(closes1W);
                    
                    // Volatility
                    indicators.volatility30d = App.HolderEngine.Indicators.calculateVolatility(closes1D, 30);
                    indicators.atr14 = App.HolderEngine.Indicators.calculateATR(ohlc1D, 14);
                    
                    // SMA
                    indicators.sma50 = App.HolderEngine.Indicators.calculateSMA(closes1D, 50);
                    indicators.sma200 = App.HolderEngine.Indicators.calculateSMA(closes1D, 200);
                    
                    // Trend analysis
                    indicators.trend = App.HolderEngine.Trend.analyzeTrend(closes1D);
                    indicators.trendPeriods = App.HolderEngine.Trend.getTrend30_90_180(closes1D);
                    
                    // Fibonacci levels (using 1W data for swing detection)
                    if (closes1W.length >= 20) {
                        const high = Math.max(...closes1W.slice(-20));
                        const low = Math.min(...closes1W.slice(-20));
                        indicators.fibonacci = App.HolderEngine.Fibonacci.calculateLevels(high, low);
                        
                        const currentPrice = App.State.marketData[symbolLower]?.price || closes1D[closes1D.length - 1];
                        indicators.nearestFib = App.HolderEngine.Fibonacci.getNearestLevel(currentPrice, indicators.fibonacci);
                    }
                    
                    // Support and resistance (simplified)
                    if (closes1D.length >= 50) {
                        // Simple support as lowest of last 50 days
                        indicators.support = Math.min(...closes1D.slice(-50));
                        indicators.resistance = Math.max(...closes1D.slice(-50));
                        
                        const currentPrice = App.State.marketData[symbolLower]?.price || closes1D[closes1D.length - 1];
                        indicators.supportDistance = ((currentPrice - indicators.support) / currentPrice) * 100;
                        indicators.resistanceDistance = ((indicators.resistance - currentPrice) / currentPrice) * 100;
                    }
                    
                    // Asymmetry calculation
                    if (indicators.support && indicators.resistance) {
                        const currentPrice = App.State.marketData[symbolLower]?.price || closes1D[closes1D.length - 1];
                        indicators.asymmetry = App.HolderEngine.Asymmetry.calculate(
                            currentPrice,
                            indicators.support,
                            indicators.resistance
                        );
                    }
                    
                    // Store indicators
                    App.State.indicatorsData[symbol] = indicators;
                },
                
                calculateHolderScore(symbol) {
                    const indicators = App.State.indicatorsData[symbol];
                    const marketData = App.State.marketData[symbol.toLowerCase()];
                    
                    if (!indicators || !marketData) return;
                    
                    // Prepare data for score calculation
                    const scoreData = {
                        rsi1D: indicators.rsi1D,
                        rsi1W: indicators.rsi1W,
                        supportDistance: indicators.supportDistance || 0,
                        fibDistance: indicators.nearestFib?.distance || 0,
                        marketCapRank: 10, // Placeholder - would come from CoinGecko
                        volumeRatio: (marketData.volume24h / 1e9) / 100, // Placeholder ratio
                        volatility30d: indicators.volatility30d || 50,
                        trendAlignment: indicators.trend?.strength || 0.5,
                        asymmetry: indicators.asymmetry || 1.0
                    };
                    
                    // Calculate score
                    App.State.scoreData[symbol] = App.HolderEngine.Score.calculate(scoreData);
                },
                
                initWebSocket() {
                    // WebSocket for real-time price updates
                    const ws = new WebSocket('wss://stream.binance.com:9443/ws/!ticker@arr');
                    
                    ws.onopen = () => {
                        console.log('🔗 WebSocket connected');
                    };
                    
                    ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        
                        data.forEach(ticker => {
                            const symbol = ticker.s.toUpperCase();
                            const symbolLower = symbol.toLowerCase();
                            
                            // Only process tokens we're monitoring
                            if (!App.State.tokens.includes(symbol)) return;
                            
                            // Update market data
                            if (App.State.marketData[symbolLower]) {
                                App.State.marketData[symbolLower].price = parseFloat(ticker.c);
                                App.State.marketData[symbolLower].change24h = parseFloat(ticker.P);
                                App.State.marketData[symbolLower].volume24h = parseFloat(ticker.v);
                                
                                // Update UI for this token
                                App.UI.updateCard(symbol);
                            }
                        });
                        
                        // Update ranking periodically
                        if (Date.now() - App.State.lastUpdate > 30000) { // Every 30 seconds
                            App.UI.renderRanking();
                            App.UI.updateStats();
                            App.State.lastUpdate = Date.now();
                        }
                    };
                    
                    ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                    };
                    
                    ws.onclose = () => {
                        console.log('WebSocket disconnected, reconnecting...');
                        setTimeout(() => this.initWebSocket(), 3000);
                    };
                    
                    App.State.ws = ws;
                },
                
                setupPeriodicUpdates() {
                    // Update global context every 5 minutes
                    setInterval(() => {
                        App.GlobalContext.update();
                    }, 300000);
                    
                    // Update token data every 10 minutes
                    setInterval(async () => {
                        for (const symbol of App.State.tokens) {
                            await App.Core.loadTokenData(symbol);
                        }
                        App.UI.renderCards();
                        App.UI.renderRanking();
                    }, 600000);
                },
                
                initTooltips() {
                    const tooltipEl = document.getElementById('metric-tooltip');
                    
                    // Simple tooltip implementation
                    document.addEventListener('click', (e) => {
                        const tooltipTarget = e.target.closest('[data-tooltip]');
                        
                        if (tooltipTarget) {
                            const tooltipText = tooltipTarget.getAttribute('data-tooltip');
                            const metric = tooltipTarget.getAttribute('data-metric');
                            
                            if (tooltipText) {
                                tooltipEl.innerHTML = `
                                    <div class="p-4">
                                        <h4 class="text-brand-500 font-bold mb-2">${metric || 'Informação'}</h4>
                                        <p class="text-sm text-gray-300">${tooltipText}</p>
                                    </div>
                                `;
                                tooltipEl.classList.remove('tooltip-hidden');
                                tooltipEl.classList.add('tooltip-visible');
                            }
                        } else if (!e.target.closest('#metric-tooltip')) {
                            tooltipEl.classList.remove('tooltip-visible');
                            tooltipEl.classList.add('tooltip-hidden');
                        }
                    });
                }
            },

            // ============================================================================
            // 8. UI RENDERING ENGINE
            // ============================================================================
            UI: {
                renderCards() {
                    const container = document.getElementById('cards-grid');
                    if (!container) return;
                    
                    container.innerHTML = '';
                    
                    App.State.tokens.forEach(symbol => {
                        const card = this.createCard(symbol);
                        container.appendChild(card);
                    });
                },
                
                createCard(symbol) {
                    const template = document.getElementById('card-template');
                    const card = template.content.cloneNode(true).querySelector('.glass');
                    
                    const symbolLower = symbol.toLowerCase();
                    const marketData = App.State.marketData[symbolLower];
                    const indicators = App.State.indicatorsData[symbol];
                    const scoreData = App.State.scoreData[symbol];
                    
                    if (!marketData) return card;
                    
                    // Set basic info
                    card.querySelector('.symbol-ticker').textContent = symbol.replace('USDT', '');
                    card.querySelector('.price-display').textContent = `$${marketData.price.toFixed(2)}`;
                    card.querySelector('.remove-token').onclick = () => App.Token.remove(symbol);
                    card.onclick = () => this.showAnalysis(symbol);
                    
                    // Score badge
                    const scoreBadge = card.querySelector('.score-badge');
                    if (scoreData) {
                        const score = scoreData.total;
                        scoreBadge.textContent = score;
                        
                        // Color coding
                        if (score >= 70) {
                            scoreBadge.style.background = 'linear-gradient(135deg, #059669, #10b981)';
                        } else if (score >= 40) {
                            scoreBadge.style.background = 'linear-gradient(135deg, #3b82f6, #60a5fa)';
                        } else {
                            scoreBadge.style.background = 'linear-gradient(135deg, #dc2626, #ef4444)';
                        }
                    }
                    
                    // Score value
                    if (scoreData) {
                        card.querySelector('.score-value').textContent = scoreData.total;
                        card.querySelector('.score-value').className = `text-lg font-bold ${
                            scoreData.total >= 70 ? 'text-green-500' : 
                            scoreData.total >= 40 ? 'text-blue-500' : 'text-red-500'
                        }`;
                    }
                    
                    // Asymmetry
                    if (indicators?.asymmetry) {
                        const asymmetryValue = card.querySelector('.asymmetry-value');
                        asymmetryValue.textContent = `${indicators.asymmetry.toFixed(2)}x`;
                        
                        const interpretation = App.HolderEngine.Asymmetry.getInterpretation(indicators.asymmetry);
                        asymmetryValue.className = `text-lg font-bold ${interpretation.color}`;
                    }
                    
                    // Progress bars
                    if (indicators) {
                        const upside = card.querySelector('.upside-potential');
                        const downside = card.querySelector('.downside-risk');
                        
                        if (indicators.resistanceDistance) {
                            upside.style.width = `${Math.min(indicators.resistanceDistance, 100)}%`;
                        }
                        
                        if (indicators.supportDistance) {
                            downside.style.width = `${Math.min(indicators.supportDistance, 100)}%`;
                        }
                    }
                    
                    // Quick stats
                    if (marketData) {
                        // Market cap placeholder (would come from CoinGecko)
                        const marketCap = marketData.volume24h * 100; // Simplified
                        card.querySelector('.market-cap').textContent = marketCap >= 1e9 ? 
                            `$${(marketCap / 1e9).toFixed(1)}B` : 
                            `$${(marketCap / 1e6).toFixed(1)}M`;
                    }
                    
                    if (indicators?.volatility30d) {
                        card.querySelector('.volatility').textContent = `${indicators.volatility30d.toFixed(1)}%`;
                    }
                    
                    if (indicators?.rsi1D) {
                        const rsiEl = card.querySelector('.rsi-1d');
                        rsiEl.textContent = indicators.rsi1D.toFixed(1);
                        rsiEl.className = `text-white ${
                            indicators.rsi1D < 30 ? 'text-green-400' : 
                            indicators.rsi1D > 70 ? 'text-red-400' : 'text-yellow-400'
                        }`;
                    }
                    
                    if (indicators?.nearestFib?.distance) {
                        card.querySelector('.ath-distance').textContent = `${indicators.nearestFib.distance.toFixed(1)}%`;
                    }
                    
                    // Action button
                    const actionButton = card.querySelector('.action-button');
                    if (scoreData) {
                        actionButton.textContent = scoreData.recommendation.action;
                        actionButton.className = `w-full mt-2 ${scoreData.recommendation.badge} rounded-lg py-2 text-sm font-bold text-white`;
                    }
                    
                    return card;
                },
                
                updateCard(symbol) {
                    const card = document.querySelector(`[data-symbol="${symbol}"]`);
                    if (!card) return;
                    
                    // Update price if card exists
                    const marketData = App.State.marketData[symbol.toLowerCase()];
                    if (marketData) {
                        const priceEl = card.querySelector('.price-display');
                        if (priceEl) {
                            priceEl.textContent = `$${marketData.price.toFixed(2)}`;
                        }
                    }
                },
                
                renderRanking() {
                    const tbody = document.getElementById('ranking-body');
                    if (!tbody) return;
                    
                    // Prepare data for ranking
                    const rankingData = [];
                    
                    App.State.tokens.forEach(symbol => {
                        const symbolLower = symbol.toLowerCase();
                        const marketData = App.State.marketData[symbolLower];
                        const indicators = App.State.indicatorsData[symbol];
                        const scoreData = App.State.scoreData[symbol];
                        
                        if (!marketData || !scoreData) return;
                        
                        rankingData.push({
                            symbol,
                            price: marketData.price,
                            score: scoreData.total,
                            rsi1D: indicators?.rsi1D,
                            volatility30d: indicators?.volatility30d,
                            asymmetry: indicators?.asymmetry,
                            athDistance: indicators?.nearestFib?.distance,
                            scoreData
                        });
                    });
                    
                    // Sort by score (descending)
                    rankingData.sort((a, b) => b.score - a.score);
                    
                    // Render rows
                    tbody.innerHTML = '';
                    
                    rankingData.forEach((token, index) => {
                        const row = document.createElement('tr');
                        row.className = `border-b border-gray-800 hover:bg-white/5 cursor-pointer`;
                        row.onclick = () => this.showAnalysis(token.symbol);
                        
                        // Score color
                        const scoreColor = token.score >= 70 ? 'text-green-500' : 
                                         token.score >= 40 ? 'text-blue-500' : 'text-red-500';
                        
                        // RSI color
                        const rsiColor = !token.rsi1D ? 'text-gray-500' :
                                        token.rsi1D < 30 ? 'text-green-500' :
                                        token.rsi1D > 70 ? 'text-red-500' : 'text-yellow-500';
                        
                        // Asymmetry interpretation
                        const asymmetryText = token.asymmetry ? 
                            App.HolderEngine.Asymmetry.getInterpretation(token.asymmetry).text : '--';
                        
                        row.innerHTML = `
                            <td class="p-3 text-center text-gray-500 font-bold">${index + 1}</td>
                            <td class="p-3 font-bold text-white">${token.symbol.replace('USDT', '')}</td>
                            <td class="p-3 text-center font-bold ${scoreColor}">${token.score}</td>
                            <td class="p-3 text-center ${rsiColor}">${token.rsi1D ? token.rsi1D.toFixed(1) : '--'}</td>
                            <td class="p-3 text-center mobile-hide">${token.volatility30d ? token.volatility30d.toFixed(1) + '%' : '--'}</td>
                            <td class="p-3 text-center mobile-hide">$${(token.price * 1e7).toFixed(1)}M</td>
                            <td class="p-3 text-center">${token.asymmetry ? token.asymmetry.toFixed(2) + 'x' : '--'}</td>
                            <td class="p-3 text-center">${token.athDistance ? token.athDistance.toFixed(1) + '%' : '--'}</td>
                            <td class="p-3 text-center">
                                <span class="text-xs px-2 py-1 rounded-full ${token.scoreData.recommendation.badge}">
                                    ${token.scoreData.recommendation.action}
                                </span>
                            </td>
                        `;
                        
                        tbody.appendChild(row);
                    });
                },
                
                updateStats() {
                    const tokens = App.State.tokens.length;
                    let opportunities = 0;
                    let risks = 0;
                    let totalAsymmetry = 0;
                    let asymmetryCount = 0;
                    
                    // Calculate stats
                    App.State.tokens.forEach(symbol => {
                        const scoreData = App.State.scoreData[symbol];
                        const indicators = App.State.indicatorsData[symbol];
                        
                        if (scoreData) {
                            if (scoreData.total >= 70) opportunities++;
                            if (scoreData.total < 40) risks++;
                        }
                        
                        if (indicators?.asymmetry) {
                            totalAsymmetry += indicators.asymmetry;
                            asymmetryCount++;
                        }
                    });
                    
                    // Update UI
                    document.getElementById('stats-tokens').textContent = tokens;
                    document.getElementById('stats-opportunities').textContent = opportunities;
                    document.getElementById('stats-risks').textContent = risks;
                    
                    const avgAsymmetry = asymmetryCount > 0 ? (totalAsymmetry / asymmetryCount) : 0;
                    document.getElementById('stats-asymmetry').textContent = avgAsymmetry.toFixed(2) + 'x';
                },
                
                showAnalysis(symbol) {
                    const panel = document.getElementById('analysis-panel');
                    const content = document.getElementById('analysis-content');
                    
                    if (!panel || !content) return;
                    
                    // Load analysis template
                    const template = document.getElementById('analysis-template');
                    const analysis = template.content.cloneNode(true);
                    
                    const symbolLower = symbol.toLowerCase();
                    const marketData = App.State.marketData[symbolLower];
                    const indicators = App.State.indicatorsData[symbol];
                    const scoreData = App.State.scoreData[symbol];
                    
                    if (!marketData || !scoreData) return;
                    
                    // Set basic info
                    analysis.querySelector('.symbol-ticker').textContent = symbol.replace('USDT', '');
                    analysis.querySelector('.price-display').textContent = `$${marketData.price.toFixed(2)}`;
                    
                    // Score badge
                    const scoreBadge = analysis.querySelector('.score-badge-large');
                    scoreBadge.textContent = scoreData.total;
                    scoreBadge.style.background = scoreData.total >= 70 ? 
                        'linear-gradient(135deg, #059669, #10b981)' :
                        scoreData.total >= 40 ?
                        'linear-gradient(135deg, #3b82f6, #60a5fa)' :
                        'linear-gradient(135deg, #dc2626, #ef4444)';
                    
                    // Recommendation badge
                    const recBadge = analysis.querySelector('.recommendation-badge');
                    recBadge.textContent = scoreData.recommendation.action;
                    recBadge.className = `badge ${scoreData.recommendation.badge}`;
                    
                    // Score breakdown
                    if (scoreData.components) {
                        const components = ['rsi', 'support', 'market', 'volatility', 'asymmetry'];
                        components.forEach((comp, index) => {
                            const score = scoreData.components[comp] || 50;
                            const progressBar = analysis.querySelectorAll('.progress-fill')[index];
                            const scoreValue = analysis.querySelectorAll('.text-sm.font-bold')[index + 1];
                            
                            if (progressBar) {
                                progressBar.style.width = `${score}%`;
                                progressBar.className = `progress-fill ${
                                    score >= 70 ? 'bg-green-500' : 
                                    score >= 40 ? 'bg-blue-500' : 'bg-red-500'
                                }`;
                            }
                            
                            if (scoreValue) {
                                scoreValue.textContent = `${score}/100`;
                            }
                        });
                    }
                    
                    // Detailed metrics
                    if (marketData) {
                        analysis.querySelector('.market-cap').textContent = `$${(marketData.volume24h * 100 / 1e9).toFixed(1)}B`;
                        analysis.querySelector('.market-cap-rank').textContent = 'Rank: ~10';
                        
                        analysis.querySelector('.volume-24h').textContent = `$${(marketData.volume24h / 1e6).toFixed(1)}M`;
                        analysis.querySelector('.volume-ratio').textContent = 'Vol/MCap: ~0.05';
                    }
                    
                    if (indicators) {
                        analysis.querySelector('.volatility-30d').textContent = `${indicators.volatility30d?.toFixed(1) || '--'}%`;
                        analysis.querySelector('.volatility-status').textContent = indicators.volatility30d < 40 ? 'Baixa' : 'Alta';
                        
                        analysis.querySelector('.ath-distance').textContent = `${indicators.nearestFib?.distance?.toFixed(1) || '--'}%`;
                        analysis.querySelector('.ath-status').textContent = indicators.nearestFib?.level === 'f0618' ? 'Próximo Fib' : 'Distante';
                        
                        if (indicators.sma50 && indicators.sma200) {
                            const ratio = indicators.sma50 / indicators.sma200;
                            analysis.querySelector('.sma-ratio').textContent = ratio.toFixed(2);
                            analysis.querySelector('.sma-status').textContent = ratio > 1 ? 'Bullish' : 'Bearish';
                        }
                        
                        if (indicators.asymmetry) {
                            analysis.querySelector('.asymmetry-value').textContent = `${indicators.asymmetry.toFixed(2)}x`;
                            const interpretation = App.HolderEngine.Asymmetry.getInterpretation(indicators.asymmetry);
                            analysis.querySelector('.asymmetry-status').textContent = interpretation.text;
                        }
                    }
                    
                    // Analysis text
                    const analysisText = analysis.getElementById('analysis-text');
                    if (analysisText && scoreData.recommendation) {
                        analysisText.innerHTML = `
                            <h6 class="text-white font-bold mb-2">Análise Holder</h6>
                            <p class="mb-3">${scoreData.recommendation.explanation}</p>
                            
                            <div class="grid grid-cols-2 gap-4 text-sm">
                                <div>
                                    <h6 class="text-gray-400 mb-1">Pontos Fortes</h6>
                                    <ul class="list-disc pl-4 text-green-400">
                                        ${indicators?.rsi1D < 40 ? '<li>RSI em zona de oversold</li>' : ''}
                                        ${indicators?.supportDistance < 10 ? '<li>Próximo de suporte técnico</li>' : ''}
                                        ${indicators?.asymmetry >= 2.0 ? '<li>Assimetria favorável</li>' : ''}
                                        ${!indicators?.rsi1D || indicators?.rsi1D > 40 ? '<li>RSI em equilíbrio</li>' : ''}
                                    </ul>
                                </div>
                                <div>
                                    <h6 class="text-gray-400 mb-1">Riscos</h6>
                                    <ul class="list-disc pl-4 text-red-400">
                                        ${indicators?.volatility30d > 60 ? '<li>Alta volatilidade</li>' : ''}
                                        ${indicators?.rsi1D > 70 ? '<li>RSI sobrecomprado</li>' : ''}
                                        ${indicators?.asymmetry < 1.0 ? '<li>Risco maior que retorno</li>' : ''}
                                        ${!indicators?.volatility30d || indicators?.volatility30d <= 60 ? '<li>Volatilidade controlada</li>' : ''}
                                    </ul>
                                </div>
                            </div>
                        `;
                    }
                    
                    // Chart
                    const chartContainer = analysis.querySelector('.chart-container');
                    if (chartContainer && App.State.ohlcData[symbol]?.['1D']) {
                        setTimeout(() => {
                            this.renderChart(chartContainer, symbol);
                        }, 100);
                    }
                    
                    // Set content and show panel
                    content.innerHTML = '';
                    content.appendChild(analysis);
                    
                    panel.classList.remove('hidden');
                    
                    // Scroll to panel
                    panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
                },
                
                renderChart(container, symbol) {
                    const ohlcData = App.State.ohlcData[symbol]?.['1D'];
                    if (!ohlcData || ohlcData.length === 0) return;
                    
                    // Create chart
                    const chart = LightweightCharts.createChart(container, {
                        layout: {
                            background: { color: '#000000' },
                            textColor: '#D9D9D9',
                        },
                        grid: {
                            vertLines: { color: '#2B2B43' },
                            horzLines: { color: '#2B2B43' },
                        },
                        timeScale: {
                            timeVisible: true,
                            secondsVisible: false,
                        },
                        crosshair: {
                            mode: LightweightCharts.CrosshairMode.Normal,
                        },
                    });
                    
                    const candleSeries = chart.addCandlestickSeries({
                        upColor: '#26a69a',
                        downColor: '#ef5350',
                        borderVisible: false,
                        wickUpColor: '#26a69a',
                        wickDownColor: '#ef5350',
                    });
                    
                    // Format data for chart
                    const chartData = ohlcData.map(candle => ({
                        time: candle.time / 1000,
                        open: candle.open,
                        high: candle.high,
                        low: candle.low,
                        close: candle.close,
                    }));
                    
                    candleSeries.setData(chartData);
                    chart.timeScale().fitContent();
                },
                
                closeAnalysis() {
                    const panel = document.getElementById('analysis-panel');
                    panel.classList.add('hidden');
                }
            },

            // ============================================================================
            // 9. SETTINGS MODULE
            // ============================================================================
            Settings: {
                openModal() {
                    const modal = document.getElementById('settings-modal');
                    const content = document.getElementById('settings-content');
                    
                    if (!modal || !content) return;
                    
                    content.innerHTML = this.renderSettings();
                    modal.classList.remove('hidden');
                },
                
                closeModal() {
                    document.getElementById('settings-modal').classList.add('hidden');
                },
                
                renderSettings() {
                    const { settings } = App.State;
                    
                    return `
                        <div class="space-y-6">
                            <div>
                                <h4 class="text-white font-bold mb-4">Tokens Monitorados</h4>
                                <div class="flex flex-wrap gap-2 mb-4">
                                    ${App.State.tokens.map(token => `
                                        <span class="bg-dark-800 px-3 py-1 rounded-full text-sm flex items-center gap-2">
                                            ${token.replace('USDT', '')}
                                            <button onclick="App.Token.remove('${token}')" class="text-red-500 hover:text-red-400">
                                                <i class="fa-solid fa-times text-xs"></i>
                                            </button>
                                        </span>
                                    `).join('')}
                                </div>
                                
                                <div class="flex gap-2">
                                    <input type="text" id="settings-add-token" placeholder="BTC, ETH, SOL..." class="flex-1 bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white">
                                    <button onclick="this.addTokenFromSettings()" class="bg-brand-600 hover:bg-brand-500 text-white px-4 py-2 rounded-lg">
                                        Adicionar
                                    </button>
                                </div>
                            </div>
                            
                            <div>
                                <h4 class="text-white font-bold mb-4">Configurações de Atualização</h4>
                                <div class="space-y-3">
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" ${settings.autoRefresh ? 'checked' : ''} onchange="App.Settings.toggleAutoRefresh(this.checked)" class="rounded">
                                        <span class="text-gray-300">Atualização Automática</span>
                                    </label>
                                    
                                    <div>
                                        <label class="text-gray-300 mb-1 block">Intervalo (segundos)</label>
                                        <input type="number" value="${settings.refreshInterval}" onchange="App.Settings.setRefreshInterval(this.value)" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white">
                                    </div>
                                </div>
                            </div>
                            
                            <div>
                                <h4 class="text-white font-bold mb-4">Exibição de Métricas</h4>
                                <div class="space-y-2">
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" ${settings.showVolatility ? 'checked' : ''} onchange="App.Settings.toggleMetric('showVolatility', this.checked)" class="rounded">
                                        <span class="text-gray-300">Mostrar Volatilidade</span>
                                    </label>
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" ${settings.showMarketCap ? 'checked' : ''} onchange="App.Settings.toggleMetric('showMarketCap', this.checked)" class="rounded">
                                        <span class="text-gray-300">Mostrar Market Cap</span>
                                    </label>
                                    <label class="flex items-center gap-2">
                                        <input type="checkbox" ${settings.showAsymmetry ? 'checked' : ''} onchange="App.Settings.toggleMetric('showAsymmetry', this.checked)" class="rounded">
                                        <span class="text-gray-300">Mostrar Assimetria</span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="pt-4 border-t border-gray-800">
                                <button onclick="App.Settings.save()" class="w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded-lg">
                                    Salvar Configurações
                                </button>
                            </div>
                        </div>
                    `;
                },
                
                addTokenFromSettings() {
                    const input = document.getElementById('settings-add-token');
                    const symbol = input.value.trim().toUpperCase();
                    
                    if (!symbol) return;
                    
                    const fullSymbol = symbol.endsWith('USDT') ? symbol : symbol + 'USDT';
                    
                    if (!App.State.tokens.includes(fullSymbol)) {
                        App.State.tokens.push(fullSymbol);
                        localStorage.setItem('holder_tokens_v13', JSON.stringify(App.State.tokens));
                        
                        // Load data for new token
                        App.Core.loadTokenData(fullSymbol).then(() => {
                            App.UI.renderCards();
                            App.UI.renderRanking();
                            this.openModal(); // Reopen modal to refresh list
                        });
                    }
                    
                    input.value = '';
                },
                
                toggleAutoRefresh(enabled) {
                    App.State.settings.autoRefresh = enabled;
                    this.saveSettings();
                },
                
                setRefreshInterval(interval) {
                    App.State.settings.refreshInterval = parseInt(interval) || 300;
                    this.saveSettings();
                },
                
                toggleMetric(metric, enabled) {
                    App.State.settings[metric] = enabled;
                    this.saveSettings();
                },
                
                saveSettings() {
                    localStorage.setItem('holder_settings_v13', JSON.stringify(App.State.settings));
                    this.closeModal();
                    
                    // Show confirmation
                    alert('Configurações salvas com sucesso!');
                }
            },

            // ============================================================================
            // 10. EXPORT MODULE
            // ============================================================================
            Export: {
                generateReport() {
                    const data = [];
                    
                    App.State.tokens.forEach(symbol => {
                        const symbolLower = symbol.toLowerCase();
                        const marketData = App.State.marketData[symbolLower];
                        const indicators = App.State.indicatorsData[symbol];
                        const scoreData = App.State.scoreData[symbol];
                        
                        if (!marketData || !scoreData) return;
                        
                        data.push({
                            Token: symbol.replace('USDT', ''),
                            Preço: marketData.price,
                            'Variação 24h': marketData.change24h,
                            'Score Holder': scoreData.total,
                            Recomendação: scoreData.recommendation.action,
                            'RSI 1D': indicators?.rsi1D?.toFixed(2) || '--',
                            'Volatilidade 30d': indicators?.volatility30d?.toFixed(2) || '--',
                            'Market Cap': `$${(marketData.volume24h * 100 / 1e9).toFixed(2)}B`,
                            Assimetria: indicators?.asymmetry?.toFixed(2) || '--',
                            'Distância ATH': indicators?.nearestFib?.distance?.toFixed(2) || '--',
                            'Volume 24h': `$${(marketData.volume24h / 1e6).toFixed(2)}M`,
                            Timestamp: new Date().toLocaleString()
                        });
                    });
                    
                    // Add global context
                    data.push({}, {
                        Token: 'CONTEXTO GLOBAL',
                        'BTC Dominance': `${App.State.globalContext.btcDominance?.toFixed(1) || '--'}%`,
                        'Fear & Greed': App.State.globalContext.fearGreedIndex || '--',
                        'Sentimento': App.State.globalContext.marketSentiment || '--',
                        'Market Cap Total': App.State.globalContext.totalMarketCap ? 
                            `$${(App.State.globalContext.totalMarketCap / 1e12).toFixed(2)}T` : '--'
                    });
                    
                    // Create worksheet
                    const ws = XLSX.utils.json_to_sheet(data);
                    const wb = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(wb, ws, "Holder Report");
                    
                    // Generate file
                    XLSX.writeFile(wb, `CryptoPanel_Holder_${new Date().toISOString().slice(0,10)}.xlsx`);
                }
            }
        };

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        // Add method to Settings object
        App.Settings.addTokenFromSettings = App.Settings.addTokenFromSettings;

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            App.Core.init();
            
            // Set up refresh button
            document.getElementById('refreshData').addEventListener('click', async () => {
                await App.GlobalContext.update();
                await App.Token.loadAllTokens();
                App.UI.renderCards();
                App.UI.renderRanking();
                App.UI.updateStats();
            });
            
            // Set up search
            document.getElementById('searchToken').addEventListener('input', (e) => {
                const term = e.target.value.toLowerCase();
                document.querySelectorAll('#cards-grid > div').forEach(card => {
                    const symbol = card.querySelector('.symbol-ticker')?.textContent.toLowerCase();
                    card.style.display = symbol && symbol.includes(term) ? 'block' : 'none';
                });
            });
            
            // Add enter key support for token input
            document.getElementById('add-token-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') App.Token.add();
            });
        });

        // Make App available globally for debugging
        window.App = App;
    </script>
</body>
</html>
