<!DOCTYPE html>
<html lang="pt-BR" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoPanelPRO - Versão Holder (CoinGecko)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/technicalindicators/dist/technicalindicators.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', 'sans-serif'], mono: ['JetBrains Mono', 'monospace'] },
                    colors: {
                        dark: { 950: '#05070a', 900: '#0b0e14', 800: '#151a23', 700: '#232a3b', 600: '#374151' },
                        brand: { 500: '#3b82f6', 600: '#2563eb' },
                        score: { high: '#10b981', mid: '#f59e0b', low: '#ef4444' },
                        orange: { 400: '#fb923c', 500: '#f97316', 600: '#ea580c', 700: '#c2410c' },
                        marketcap: { large: '#10b981', mid: '#f59e0b', small: '#f97316', micro: '#ef4444' },
                        cycle: { 
                            accumulation: '#10b981', 
                            earlybull: '#22c55e', 
                            midbull: '#f59e0b', 
                            euphoria: '#ef4444',
                            bear: '#6b7280'
                        }
                    },
                    animation: { 'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite' }
                }
            }
        }
    </script>

    <style>
        body { background-color: #05070a; color: #e5e7eb; overflow-x: hidden; padding-bottom: 400px; }
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0b0e14; }
        ::-webkit-scrollbar-thumb { background: #232a3b; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #3b82f6; }
        
        .glass { background: rgba(11, 14, 20, 0.95); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.08); }
        .table-fixed-header thead { position: sticky; top: 0; z-index: 20; background-color: #0b0e14; }
        .table-row-hover:hover td { background-color: rgba(59, 130, 246, 0.08); }
        
        #metric-tooltip-overlay { 
            position: fixed; bottom: 0; left: 0; right: 0;
            height: auto; max-height: 70vh;
            background-color: #05070a;
            border-top: 1px solid rgba(59, 130, 246, 0.4);
            box-shadow: 0 -10px 60px rgba(0,0,0,0.95);
            z-index: 9999;
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.3s ease;
            overflow-y: auto;
            padding: 1.5rem;
            display: flex; flex-direction: column; gap: 1rem;
        }
        @media(min-width: 1024px) { #metric-tooltip-overlay { flex-direction: row; max-height: 40vh; } }

        .tooltip-hidden { transform: translateY(110%); opacity: 0; pointer-events: none; }
        .tooltip-visible { transform: translateY(0); opacity: 1; pointer-events: auto; }

        .tip-label { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.05em; color: #60a5fa; font-weight: 800; margin-bottom: 6px; border-bottom: 1px solid rgba(96, 165, 250, 0.2); display: inline-block; }
        .tip-val { font-size: 0.9rem; color: #d1d5db; line-height: 1.6; }
        .tip-val b { color: #fff; font-weight: 700; }
        
        .card-enter { animation: slideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards; }
        @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        
        .pulse-green { animation: pulseG 0.8s; } .pulse-red { animation: pulseR 0.8s; }
        @keyframes pulseG { 0% { color: #10b981; text-shadow: 0 0 10px rgba(16,185,129,0.5); } 100% { color: inherit; } }
        @keyframes pulseR { 0% { color: #ef4444; text-shadow: 0 0 10px rgba(239,68,68,0.5); } 100% { color: inherit; } }
        .sparkline-path { stroke-dasharray: 1000; stroke-dashoffset: 1000; animation: drawSpark 2s ease-out forwards; }
        @keyframes drawSpark { to { stroke-dashoffset: 0; } }
        .modal-overlay { background-color: rgba(0,0,0,0.85); backdrop-filter: blur(4px); }
        
        /* Mobile-first responsive utilities */
        .table-responsive { overflow-x: auto; -webkit-overflow-scrolling: touch; }
        .mobile-full { width: 100%; }
        .mobile-text-sm { font-size: 0.875rem; }
        .mobile-p-3 { padding: 0.75rem; }
        
        /* Mobile card optimizations */
        @media (max-width: 640px) {
            .card-grid { grid-template-columns: 1fr; gap: 1rem; }
            .card-section { padding: 0.75rem; }
            .card-section-grid { grid-template-columns: 1fr; gap: 0.5rem; }
            .mobile-collapsible { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
            .mobile-collapsible.expanded { max-height: 1000px; }
            .mobile-toggle { display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        }

        .compact-table th, .compact-table td { padding: 0.25rem 0.5rem !important; }
        
        .alert-panel { border-color: rgba(251, 146, 60, 0.5) !important; }
        .alert-header { background-color: rgba(251, 146, 60, 0.1) !important; border-color: rgba(251, 146, 60, 0.3) !important; }
        .alert-button { background-color: #f97316 !important; }
        .alert-button:hover { background-color: #ea580c !important; }
        
        .ranking-row-high { background-color: rgba(16, 185, 129, 0.1) !important; }
        .ranking-row-mid { background-color: rgba(59, 130, 246, 0.1) !important; }
        .ranking-row-low { background-color: rgba(239, 68, 68, 0.1) !important; }
        
        .badge-marketcap-large { background-color: rgba(16, 185, 129, 0.2); border-color: #10b981; color: #10b981; }
        .badge-marketcap-mid { background-color: rgba(245, 158, 11, 0.2); border-color: #f59e0b; color: #f59e0b; }
        .badge-marketcap-small { background-color: rgba(251, 146, 60, 0.2); border-color: #fb923c; color: #fb923c; }
        .badge-marketcap-micro { background-color: rgba(239, 68, 68, 0.2); border-color: #ef4444; color: #ef4444; }
        
        .progress-bar { height: 4px; background-color: #374151; border-radius: 2px; overflow: hidden; }
        .progress-fill { height: 100%; transition: width 0.3s ease; }
        
        .filter-active { background-color: #3b82f6 !important; color: white !important; border-color: #3b82f6 !important; }
        
        /* Novas classes para ciclo */
        .cycle-badge-accumulation { background-color: rgba(16, 185, 129, 0.2); border-color: #10b981; color: #10b981; }
        .cycle-badge-earlybull { background-color: rgba(34, 197, 94, 0.2); border-color: #22c55e; color: #22c55e; }
        .cycle-badge-midbull { background-color: rgba(245, 158, 11, 0.2); border-color: #f59e0b; color: #f59e0b; }
        .cycle-badge-euphoria { background-color: rgba(239, 68, 68, 0.2); border-color: #ef4444; color: #ef4444; }
        .cycle-badge-bear { background-color: rgba(107, 114, 128, 0.2); border-color: #6b7280; color: #6b7280; }
        
        /* Classe para badge de assimetria */
        .asymmetry-badge { 
            font-size: 9px; 
            padding: 2px 6px; 
            border-radius: 10px; 
            font-weight: 800; 
            text-transform: uppercase;
        }
        .asymmetry-very-high { background-color: rgba(16, 185, 129, 0.2); border: 1px solid #10b981; color: #10b981; }
        .asymmetry-high { background-color: rgba(34, 197, 94, 0.2); border: 1px solid #22c55e; color: #22c55e; }
        .asymmetry-medium { background-color: rgba(245, 158, 11, 0.2); border: 1px solid #f59e0b; color: #f59e0b; }
        .asymmetry-low { background-color: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444; color: #ef4444; }
    </style>
</head>
<body class="antialiased min-h-screen flex flex-col font-sans selection:bg-brand-500 selection:text-white">

    <!-- Header -->
    <header class="glass sticky top-0 z-50 border-b border-gray-800 shadow-lg">
        <div class="max-w-[1800px] mx-auto px-2 sm:px-4 h-16 flex items-center justify-between flex-wrap sm:flex-nowrap gap-2 py-2 min-w-[320px]">
            <div class="flex items-center gap-2 sm:gap-4 w-full sm:w-auto justify-between sm:justify-start">
                <div class="flex items-center gap-2">
                    <div class="w-8 h-8 sm:w-10 sm:h-10 bg-gradient-to-br from-brand-600 to-indigo-800 rounded-lg flex items-center justify-center shadow-lg shadow-brand-glow cursor-help" data-tip="sys_logo">
                        <i class="fa-solid fa-layer-group text-white text-sm sm:text-lg"></i>
                    </div>
                    <div>
                        <h1 class="font-bold text-base sm:text-xl text-white tracking-tight">CryptoPanel<span class="text-brand-500">HOLDER</span> <span class="text-[8px] sm:text-[10px] text-gray-500 border border-gray-700 rounded px-1 ml-1 align-top">v13.5 CG</span></h1>
                        <div class="flex items-center gap-1 sm:gap-2 text-[8px] sm:text-[10px] text-gray-400 font-mono mt-0 sm:mt-1">
                            <span class="hidden sm:inline">COINGECKO • FUNDAMENTALS • LONG TERM</span>
                            <span class="w-1 h-1 rounded-full bg-gray-600 hidden sm:inline"></span>
                            <span id="last-update" data-tip="sys_update">Conectando...</span>
                        </div>
                    </div>
                </div>
                <div class="flex items-center gap-1 sm:hidden">
                    <button id="mobile-menu-toggle" class="p-2 bg-dark-800 border border-gray-700 rounded-lg">
                        <i class="fa-solid fa-bars text-white"></i>
                    </button>
                </div>
            </div>
            <div id="header-controls" class="hidden sm:flex items-center gap-2 sm:gap-3 w-full sm:w-auto justify-end mt-2 sm:mt-0">
                <input id="searchToken" type="text" placeholder="Buscar token..." class="bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-sm text-white focus:border-brand-500 outline-none w-full sm:w-40 mobile-full">
                <div class="hidden sm:flex flex-col items-end mr-2 cursor-help" data-tip="sys_auto_refresh">
                    <span class="text-[9px] text-gray-500 uppercase tracking-widest">Auto-Refresh</span>
                    <span id="countdown" class="text-xs font-mono font-bold text-brand-500">300s</span>
                </div>
                <div class="flex gap-1 sm:gap-2">
                    <button onclick="App.Export.openModal()" class="p-2 bg-dark-800 hover:text-green-400 border border-gray-700 rounded-lg transition-all min-h-[40px] min-w-[40px] flex items-center justify-center" data-tip="sys_export"><i class="fa-solid fa-file-excel"></i></button>
                    <button id="refreshData" class="group p-2 bg-brand-600 hover:bg-brand-500 rounded-lg text-white shadow-lg min-h-[40px] min-w-[40px] flex items-center justify-center" data-tip="sys_manual_refresh"><i class="fa-solid fa-rotate group-hover:rotate-180 transition-transform duration-500"></i></button>
                    <button id="openSettings" class="p-2 bg-dark-800 hover:text-yellow-400 border border-gray-700 rounded-lg transition-all min-h-[40px] min-w-[40px] flex items-center justify-center" data-tip="sys_settings"><i class="fa-solid fa-gear"></i></button>
                    <button onclick="App.Portfolio.openModal()" class="p-2 bg-dark-800 hover:text-purple-400 border border-gray-700 rounded-lg transition-all min-h-[40px] min-w-[40px] flex items-center justify-center" data-tip="sys_portfolio"><i class="fa-solid fa-wallet"></i></button>
                </div>
            </div>
        </div>
    </header>

    <!-- Filtros CoinGecko -->
    <div class="bg-dark-900 border-b border-gray-800 py-3 shadow-inner">
        <div class="max-w-[1800px] mx-auto px-2 sm:px-4">
            <div class="flex flex-col sm:flex-row gap-4">
                <div class="flex-1">
                    <div class="flex flex-wrap gap-2 items-center">
                        <span class="font-bold text-gray-500 uppercase tracking-widest text-[9px] sm:text-[10px] shrink-0 flex items-center">Filtros:</span>
                        
                        <!-- Estratégias Holder -->
                        <div class="flex gap-1">
                            <button class="strategy-btn px-2 py-1 bg-dark-800 border border-gray-700 rounded text-[10px] sm:text-xs hover:bg-dark-700" data-strategy="bluechips">Blue Chips</button>
                            <button class="strategy-btn px-2 py-1 bg-dark-800 border border-gray-700 rounded text-[10px] sm:text-xs hover:bg-dark-700" data-strategy="correction">Correção Sólida</button>
                            <button class="strategy-btn px-2 py-1 bg-dark-800 border border-gray-700 rounded text-[10px] sm:text-xs hover:bg-dark-700" data-strategy="asymmetry">Alta Assimetria</button>
                            <button class="strategy-btn px-2 py-1 bg-dark-800 border border-gray-700 rounded text-[10px] sm:text-xs hover:bg-dark-700" data-strategy="oversold">Oversold Técnico</button>
                        </div>
                        
                        <!-- Filtro por Market Cap -->
                        <div class="flex gap-1 ml-2">
                            <button class="filter-btn px-2 py-1 bg-dark-800 border border-gray-700 rounded text-[10px] sm:text-xs hover:bg-dark-700" data-filter="marketcap" data-value="large">Large Cap</button>
                            <button class="filter-btn px-2 py-1 bg-dark-800 border border-gray-700 rounded text-[10px] sm:text-xs hover:bg-dark-700" data-filter="marketcap" data-value="mid">Mid Cap</button>
                            <button class="filter-btn px-2 py-1 bg-dark-800 border border-gray-700 rounded text-[10px] sm:text-xs hover:bg-dark-700" data-filter="marketcap" data-value="small">Small Cap</button>
                            <button class="filter-btn px-2 py-1 bg-dark-800 border border-gray-700 rounded text-[10px] sm:text-xs hover:bg-dark-700" data-filter="marketcap" data-value="micro">Micro Cap</button>
                        </div>
                        
                        <!-- Ordenação -->
                        <div class="flex gap-1 ml-2">
                            <select id="sort-select" class="bg-dark-800 border border-gray-700 rounded text-[10px] sm:text-xs px-2 py-1 text-white">
                                <option value="holder_score_desc">Holder Score ↓</option>
                                <option value="asymmetry_desc">Assimetria ↓</option>
                                <option value="market_cap_desc">Market Cap ↓</option>
                                <option value="market_cap_asc">Market Cap ↑</option>
                                <option value="volume_desc">Volume ↓</option>
                                <option value="ath_change_desc">Distância ATH ↓</option>
                                <option value="rsi_asc">RSI ↑ (mais oversold)</option>
                                <option value="rsi_desc">RSI ↓ (mais overbought)</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="flex gap-2">
                    <button id="load-more" class="px-3 py-1 bg-brand-600 hover:bg-brand-500 text-white rounded text-xs flex items-center gap-2">
                        <i class="fa-solid fa-plus"></i> Carregar Mais
                    </button>
                    <button id="reset-filters" class="px-3 py-1 bg-dark-800 hover:bg-dark-700 border border-gray-700 text-gray-300 rounded text-xs">
                        Limpar Filtros
                    </button>
                </div>
            </div>
        </div>
    </div>

    <main class="flex-1 max-w-[1800px] mx-auto px-2 sm:px-4 py-4 sm:py-6 w-full gap-4 sm:gap-8 flex flex-col">
        
        <!-- Painel de Stats e Ciclo -->
        <section class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-4">
            <div class="glass rounded-xl p-4 border border-gray-800">
                <div class="flex justify-between items-center">
                    <div>
                        <p class="text-gray-500 text-xs uppercase">Total Market Cap</p>
                        <p id="total-marketcap" class="text-white text-xl font-bold">$--</p>
                    </div>
                    <i class="fa-solid fa-chart-pie text-brand-500 text-2xl"></i>
                </div>
            </div>
            
            <div class="glass rounded-xl p-4 border border-gray-800">
                <div class="flex justify-between items-center">
                    <div>
                        <p class="text-gray-500 text-xs uppercase">Total Volume 24h</p>
                        <p id="total-volume" class="text-white text-xl font-bold">$--</p>
                    </div>
                    <i class="fa-solid fa-chart-line text-green-500 text-2xl"></i>
                </div>
            </div>
            
            <div class="glass rounded-xl p-4 border border-gray-800">
                <div class="flex justify-between items-center">
                    <div>
                        <p class="text-gray-500 text-xs uppercase">BTC Dominance</p>
                        <p id="btc-dominance" class="text-white text-xl font-bold">--%</p>
                    </div>
                    <i class="fa-brands fa-bitcoin text-yellow-500 text-2xl"></i>
                </div>
            </div>
            
            <div class="glass rounded-xl p-4 border border-gray-800">
                <div class="flex justify-between items-center">
                    <div>
                        <p class="text-gray-500 text-xs uppercase">ETH Dominance</p>
                        <p id="eth-dominance" class="text-white text-xl font-bold">--%</p>
                    </div>
                    <i class="fa-brands fa-ethereum text-purple-500 text-2xl"></i>
                </div>
            </div>
            
            <!-- Ciclo de Mercado -->
            <div class="glass rounded-xl p-4 border border-gray-800">
                <div class="flex justify-between items-center">
                    <div>
                        <p class="text-gray-500 text-xs uppercase">Ciclo BTC</p>
                        <p id="market-cycle" class="text-white text-lg font-bold">--</p>
                        <p id="cycle-description" class="text-gray-400 text-xs mt-1">Analisando...</p>
                    </div>
                    <i class="fa-solid fa-arrows-rotate text-cycle-accumulation text-2xl"></i>
                </div>
            </div>
        </section>

        <!-- Painel de Alertas -->
        <section id="alerts-panel" class="glass rounded-xl overflow-hidden border border-orange-500/50 flex flex-col shadow-lg alert-panel">
            <div class="bg-orange-900/20 p-4 border-b border-orange-500/30 flex justify-between items-center alert-header">
                <h3 class="text-orange-400 font-bold text-sm flex items-center gap-2" data-tip="sys_alert_panel"><i class="fa-solid fa-bell"></i> Alertas Ativos</h3>
                <button onclick="App.Alerts.openModal()" class="px-3 py-1 bg-orange-600 hover:bg-orange-500 text-white rounded-lg text-xs alert-button">+ Novo</button>
            </div>
            <div class="p-4"><div id="alertsContent" class="space-y-2 max-h-60 overflow-y-auto"></div></div>
        </section>

        <!-- Tabela Principal CoinGecko -->
        <section class="glass rounded-xl overflow-hidden border border-gray-800 flex flex-col shadow-xl">
            <div class="bg-dark-800/80 p-4 border-b border-gray-700 flex justify-between items-center shrink-0">
                <h3 class="text-white font-bold text-sm flex items-center gap-2" data-tip="rank_title_main">
                    <i class="fa-solid fa-list text-yellow-500"></i> 
                    Ranking de Oportunidades Holder (CoinGecko)
                </h3>
                <div class="text-xs text-gray-500 hidden sm:block" id="coins-count">Carregando...</div>
            </div>
            <div class="overflow-y-auto flex-1 scrollbar-thin table-fixed-header table-responsive">
                <table class="w-full text-left text-xs min-w-[1200px]">
                    <thead class="text-gray-400 uppercase font-bold tracking-wider text-[10px]">
                        <tr>
                            <th class="p-3 text-center w-12 bg-dark-900" data-tip="rank_pos">#</th>
                            <th class="p-3 bg-dark-900" data-tip="col_ticker">Token</th>
                            <th class="p-3 text-center bg-dark-900" data-tip="col_price">Preço</th>
                            <th class="p-3 text-center bg-dark-900" data-tip="col_marketcap">Market Cap</th>
                            <th class="p-3 text-center bg-dark-900" data-tip="col_volume">Volume</th>
                            <th class="p-3 text-center bg-dark-900" data-tip="ath_change">ATH %</th>
                            <th class="p-3 text-center bg-dark-900" data-tip="col_technical">RSI</th>
                            <th class="p-3 text-center bg-dark-900" data-tip="asymmetry_ratio">Assimetria</th>
                            <th class="p-3 text-center bg-dark-900" data-tip="col_score">Score</th>
                            <th class="p-3 text-right bg-dark-900" data-tip="rank_action">Ação</th>
                        </tr>
                    </thead>
                    <tbody id="coingecko-table-body" class="divide-y divide-gray-800 text-gray-300">
                        <tr><td colspan="10" class="p-8 text-center text-gray-600 italic animate-pulse">Carregando dados da CoinGecko...</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Cards dos Tokens -->
        <div class="flex flex-col sm:flex-row gap-4 items-center justify-between mt-4">
            <div class="flex items-center gap-2 w-full sm:w-auto">
                <div class="relative group w-full sm:w-64">
                    <input type="text" id="add-input" placeholder="Adicionar (ex: bitcoin)..." class="w-full bg-dark-900 border border-gray-700 rounded-lg px-4 py-2 text-sm focus:border-brand-500 outline-none shadow-inner transition-all" data-tip="input_add">
                    <button onclick="App.Token.addFromSearch()" class="absolute right-2 top-1/2 -translate-y-1/2 text-brand-500 hover:text-white p-1"><i class="fa-solid fa-plus"></i></button>
                </div>
            </div>
            <div class="text-[10px] text-gray-500 uppercase font-bold tracking-wider hidden sm:block">Monitoramento Ativo</div>
        </div>
        <div id="cards-grid" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 2xl:grid-cols-4 gap-4 sm:gap-6 pb-10 card-grid"></div>
    </main>

    <div id="metric-tooltip-overlay" class="tooltip-hidden"></div>

    <!-- Modal de Portfólio -->
    <div id="portfolioModal" class="fixed inset-0 z-[120] hidden modal-overlay flex items-center justify-center p-4">
        <div class="bg-dark-900 border border-gray-700 rounded-xl shadow-2xl w-full max-w-4xl overflow-hidden mx-2">
            <div class="bg-dark-800 p-4 border-b border-gray-700 flex justify-between items-center">
                <h3 class="text-white font-bold">Minha Carteira Holder</h3>
                <button onclick="App.Portfolio.closeModal()" class="text-gray-500 hover:text-white p-2"><i class="fa-solid fa-times"></i></button>
            </div>
            <div class="p-4 sm:p-6 space-y-6 max-h-[80vh] overflow-y-auto">
                <!-- Formulário para adicionar posição -->
                <div class="glass rounded-lg p-4">
                    <h4 class="text-white font-bold mb-4">Adicionar Posição</h4>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div>
                            <label class="block text-sm text-gray-400 mb-2">Token</label>
                            <select id="portfolio-symbol" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white focus:border-brand-500 outline-none">
                                <option value="">Selecione um token</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm text-gray-400 mb-2">Quantidade</label>
                            <input type="number" id="portfolio-quantity" step="0.000001" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white focus:border-brand-500 outline-none" placeholder="0.0">
                        </div>
                        <div>
                            <label class="block text-sm text-gray-400 mb-2">Preço Médio (USDT)</label>
                            <input type="number" id="portfolio-avg-price" step="0.0001" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white focus:border-brand-500 outline-none" placeholder="0.00">
                        </div>
                    </div>
                    <button onclick="App.Portfolio.addPosition()" class="mt-4 w-full px-4 py-2 bg-brand-600 hover:bg-brand-500 text-white rounded-lg">Adicionar à Carteira</button>
                </div>
                
                <!-- Resumo da Carteira -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="glass rounded-lg p-4">
                        <h5 class="text-gray-400 text-sm uppercase mb-2">Valor Total</h5>
                        <p id="portfolio-total-value" class="text-white text-2xl font-bold">$0.00</p>
                    </div>
                    <div class="glass rounded-lg p-4">
                        <h5 class="text-gray-400 text-sm uppercase mb-2">Lucro/Prejuízo</h5>
                        <p id="portfolio-pnl" class="text-white text-2xl font-bold">$0.00</p>
                        <p id="portfolio-pnl-percent" class="text-sm">0.00%</p>
                    </div>
                    <div class="glass rounded-lg p-4">
                        <h5 class="text-gray-400 text-sm uppercase mb-2">Score Médio</h5>
                        <p id="portfolio-avg-score" class="text-white text-2xl font-bold">0</p>
                    </div>
                </div>
                
                <!-- Distribuição por Market Cap -->
                <div class="glass rounded-lg p-4">
                    <h5 class="text-white font-bold mb-4">Distribuição por Market Cap</h5>
                    <div id="portfolio-distribution" class="space-y-2">
                        <div class="flex justify-between">
                            <span class="text-gray-400">Large Cap:</span>
                            <span class="text-white">0%</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Mid Cap:</span>
                            <span class="text-white">0%</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Small Cap:</span>
                            <span class="text-white">0%</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Micro Cap:</span>
                            <span class="text-white">0%</span>
                        </div>
                    </div>
                </div>
                
                <!-- Tabela de Posições -->
                <div class="glass rounded-lg p-4">
                    <h5 class="text-white font-bold mb-4">Posições Ativas</h5>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm">
                            <thead class="text-gray-400 uppercase">
                                <tr>
                                    <th class="p-2 text-left">Token</th>
                                    <th class="p-2 text-right">Quantidade</th>
                                    <th class="p-2 text-right">Preço Médio</th>
                                    <th class="p-2 text-right">Valor Atual</th>
                                    <th class="p-2 text-right">P/L</th>
                                    <th class="p-2 text-right">Score</th>
                                    <th class="p-2 text-right">Ação</th>
                                </tr>
                            </thead>
                            <tbody id="portfolio-positions" class="text-gray-300">
                                <!-- Posições serão renderizadas aqui -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Alertas (atualizado com novos tipos) -->
    <div id="alertsModal" class="fixed inset-0 z-[120] hidden modal-overlay flex items-center justify-center p-4">
        <div class="bg-dark-900 border border-gray-700 rounded-xl shadow-2xl w-full max-w-md sm:max-w-2xl overflow-hidden mx-2">
            <div class="bg-dark-800 p-4 border-b border-gray-700 flex justify-between items-center">
                <h3 class="text-white font-bold">Criar Alerta</h3>
                <button onclick="App.Alerts.closeModal()" class="text-gray-500 hover:text-white p-2"><i class="fa-solid fa-times"></i></button>
            </div>
            <div class="p-4 sm:p-6 space-y-4 max-h-96 overflow-y-auto">
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm text-gray-400 mb-2">Token</label>
                        <select id="alert-symbol" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white focus:border-brand-500 outline-none">
                            <option value="">Selecione um token</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm text-gray-400 mb-2">Tipo de Alerta</label>
                        <select id="alert-type" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white focus:border-brand-500 outline-none">
                            <option value="buy">Preço de Compra</option>
                            <option value="sell">Preço de Venda</option>
                            <option value="score">Holder Score</option>
                            <option value="asymmetry">Assimetria</option>
                            <option value="rsi">RSI Extremo</option>
                            <option value="ath_distance">Distância do ATH</option>
                        </select>
                    </div>
                    
                    <!-- Condicional para diferentes tipos de alerta -->
                    <div id="alert-condition-price" class="alert-condition">
                        <label class="block text-sm text-gray-400 mb-2">Preço Alvo (USDT)</label>
                        <input type="number" id="alert-price" step="0.0001" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white focus:border-brand-500 outline-none" placeholder="0.00">
                    </div>
                    
                    <div id="alert-condition-score" class="alert-condition hidden">
                        <label class="block text-sm text-gray-400 mb-2">Holder Score</label>
                        <select id="alert-score-condition" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white focus:border-brand-500 outline-none">
                            <option value="above">Acima de</option>
                            <option value="below">Abaixo de</option>
                        </select>
                        <input type="number" id="alert-score-value" min="0" max="100" class="w-full mt-2 bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white focus:border-brand-500 outline-none" placeholder="70">
                    </div>
                    
                    <div id="alert-condition-asymmetry" class="alert-condition hidden">
                        <label class="block text-sm text-gray-400 mb-2">Assimetria Mínima</label>
                        <input type="number" id="alert-asymmetry-value" step="0.1" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white focus:border-brand-500 outline-none" placeholder="3.0">
                    </div>
                    
                    <div>
                        <label class="block text-sm text-gray-400 mb-2">Observações (opcional)</label>
                        <textarea id="alert-notes" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white focus:border-brand-500 outline-none" rows="2" placeholder="Ex: Comprar quando atingir este nível..."></textarea>
                    </div>
                </div>
                <div class="flex justify-end gap-2 pt-4">
                    <button onclick="App.Alerts.closeModal()" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg">Cancelar</button>
                    <button onclick="App.Alerts.createAlert()" class="px-4 py-2 bg-brand-600 hover:bg-brand-500 text-white rounded-lg">Salvar Alerta</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Configurações -->
    <div id="settingsModal" class="fixed inset-0 z-[120] hidden modal-overlay flex items-center justify-center p-4">
        <div class="bg-dark-900 border border-gray-700 rounded-xl shadow-2xl w-full max-w-md sm:max-w-2xl overflow-hidden mx-2">
            <div class="bg-dark-800 p-4 border-b border-gray-700 flex justify-between items-center">
                <h3 class="text-white font-bold">Configurações Holder</h3>
                <button onclick="App.Settings.closeModal()" class="text-gray-500 hover:text-white p-2"><i class="fa-solid fa-times"></i></button>
            </div>
            <div class="p-4 sm:p-6 space-y-4 max-h-96 overflow-y-auto">
                <div class="text-white">Gerenciar Tokens Favoritos:</div>
                <div id="settings-tokens-list" class="flex flex-wrap gap-2 mt-2 mb-4">
                    <!-- Tokens serão renderizados aqui via JavaScript -->
                </div>
                
                <div class="text-white mb-2">Configurações CoinGecko:</div>
                <div class="space-y-3">
                    <div>
                        <label class="block text-sm text-gray-400 mb-2">Moeda de Referência</label>
                        <select id="currency-select" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white focus:border-brand-500 outline-none">
                            <option value="usd">USD (Dólar Americano)</option>
                            <option value="brl">BRL (Real Brasileiro)</option>
                            <option value="eur">EUR (Euro)</option>
                            <option value="btc">BTC (Bitcoin)</option>
                            <option value="eth">ETH (Ethereum)</option>
                        </select>
                    </div>
                    
                    <div>
                        <label class="block text-sm text-gray-400 mb-2">Número de Criptomoedas</label>
                        <select id="per-page-select" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white focus:border-brand-500 outline-none">
                            <option value="50">50</option>
                            <option value="100" selected>100</option>
                            <option value="200">200</option>
                            <option value="250">250</option>
                        </select>
                    </div>
                    
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="auto-refresh-cg" class="rounded border-gray-700 bg-dark-800">
                        <label for="auto-refresh-cg" class="text-sm text-gray-400">Atualização automática dos dados</label>
                    </div>
                    
                    <div>
                        <label class="block text-sm text-gray-400 mb-2">Intervalo de Atualização (segundos)</label>
                        <select id="refresh-interval" class="w-full bg-dark-800 border border-gray-700 rounded-lg px-3 py-2 text-white focus:border-brand-500 outline-none">
                            <option value="300">5 minutos (recomendado)</option>
                            <option value="60">1 minuto</option>
                            <option value="900">15 minutos</option>
                            <option value="1800">30 minutos</option>
                            <option value="0">Manual apenas</option>
                        </select>
                    </div>
                    
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="holder-mode" class="rounded border-gray-700 bg-dark-800" checked>
                        <label for="holder-mode" class="text-sm text-gray-400">Modo Holder Calmo (oculta timeframes curtos)</label>
                    </div>
                </div>
                
                <div class="pt-4">
                    <button onclick="App.Settings.saveCoinGeckoSettings()" class="px-4 py-2 bg-brand-600 hover:bg-brand-500 text-white rounded-lg w-full">Salvar Configurações</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal de Exportação -->
    <div id="export-modal" class="fixed inset-0 z-[120] hidden modal-overlay flex items-center justify-center p-4">
        <div class="bg-dark-900 border border-gray-700 rounded-xl shadow-2xl w-full max-w-md overflow-hidden mx-2">
            <div class="bg-dark-800 p-4 border-b border-gray-700 flex justify-between items-center">
                <h3 class="text-white font-bold">Exportar</h3>
                <button onclick="App.Export.closeModal()" class="text-gray-500 hover:text-white p-2"><i class="fa-solid fa-times"></i></button>
            </div>
            <div class="p-6 space-y-4">
                <button onclick="App.Export.genFavoritesReport()" class="w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded-lg shadow-lg">
                    <i class="fa-solid fa-file-excel mr-2"></i>Relatório Favoritos (Holder)
                </button>
                <button onclick="App.Export.genPortfolio()" class="w-full bg-brand-600 hover:bg-brand-500 text-white font-bold py-3 rounded-lg shadow-lg">
                    <i class="fa-solid fa-wallet mr-2"></i>Exportar Portfólio
                </button>
                <button onclick="App.Export.genFullAnalysis()" class="w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 rounded-lg shadow-lg">
                    <i class="fa-solid fa-chart-bar mr-2"></i>Análise Completa
                </button>
            </div>
        </div>
    </div>

    <!-- Template do Card Atualizado -->
    <template id="card-template">
        <div class="card glass rounded-xl overflow-hidden hover:border-gray-500 transition-all duration-300 card-enter flex flex-col group border-t-2 border-t-transparent shadow-lg" data-symbol="">
            <button class="btn-remove absolute top-2 right-2 text-gray-600 hover:text-red-500 z-20 opacity-0 group-hover:opacity-100 p-2 transition-opacity bg-dark-900/80 rounded-full backdrop-blur-sm" title="Remover"><i class="fa-solid fa-times"></i></button>
            
            <div class="p-4 cursor-pointer card-header relative z-10 bg-gradient-to-b from-dark-800/40 to-transparent" onclick="App.UI.toggleCard(this)">
                <div class="flex justify-between items-start mb-2">
                    <div class="flex items-center gap-3">
                        <div class="relative w-10 h-10">
                            <img class="token-logo w-10 h-10 rounded-full border border-gray-700" src="" alt="" onerror="this.src='https://cryptologos.cc/logos/bitcoin-btc-logo.png'">
                            <div class="score-badge absolute -bottom-1 -right-1 w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold text-white border border-white shadow-sm cursor-help" data-tip="m_score">--</div>
                        </div>
                        <div>
                            <h3 class="font-bold text-white text-lg symbol-ticker leading-none" data-tip="col_ticker">BTC</h3>
                            <div class="flex gap-1 mt-1">
                                <span class="marketcap-badge text-[8px] font-bold uppercase px-1.5 py-0.5 rounded" data-tip="m_marketcap">Large</span>
                                <span class="asymmetry-badge" data-tip="asymmetry_ratio">--</span>
                            </div>
                        </div>
                    </div>
                    <div class="text-right">
                        <div class="text-xl font-mono font-bold text-white price-display cursor-help" data-tip="m_price">$0.00</div>
                        <div class="text-xs font-bold percent-display text-gray-500 cursor-help" data-tip="ath_change">0.00% do ATH</div>
                    </div>
                </div>
                <div class="grid grid-cols-3 gap-1 text-[9px] font-mono text-gray-400 pt-2 border-t border-gray-800/50">
                    <div class="text-center cursor-help" data-tip="col_technical">RSI: <span class="metric-rsi text-white">--</span></div>
                    <div class="text-center cursor-help" data-tip="m_marketcap">MCap: <span class="metric-marketcap text-white">--</span></div>
                    <div class="text-center cursor-help" data-tip="m_volume">Vol: <span class="metric-volume text-white">--</span></div>
                </div>
            </div>

            <div class="card-body hidden border-t border-gray-800 bg-dark-900 relative z-20 p-4">
                <div class="h-40 sm:h-48 w-full bg-black rounded border border-gray-800 chart-container mb-4 cursor-help" data-tip="m_chart"></div>
                <div class="space-y-4">
                    <div class="bg-dark-950 p-2 rounded border border-gray-800">
                        <h5 class="text-[9px] text-gray-500 uppercase font-bold mb-1 border-b border-gray-800 pb-1">Análise Técnica</h5>
                        <div class="grid grid-cols-2 gap-2 text-[10px] font-mono">
                            <div class="cursor-help" data-tip="technical_rsi"><span class="text-gray-600 block">RSI 14d</span><span class="val-rsi text-white">--</span></div>
                            <div class="cursor-help" data-tip="technical_ma"><span class="text-gray-600 block">MA 30d</span><span class="val-ma text-white">--</span></div>
                            <div class="cursor-help" data-tip="technical_macd"><span class="text-gray-600 block">MACD</span><span class="val-macd text-white">--</span></div>
                            <div class="cursor-help" data-tip="technical_volatility"><span class="text-gray-600 block">Volatilidade</span><span class="val-volatility text-white">--</span></div>
                        </div>
                    </div>
                    
                    <div class="bg-dark-950 p-2 rounded border border-gray-800">
                        <h5 class="text-[9px] text-gray-500 uppercase font-bold mb-1 border-b border-gray-800 pb-1 cursor-help" data-tip="asymmetry_analysis">Assimetria Risco/Recompensa</h5>
                        <div class="space-y-1 text-[10px] font-mono">
                            <div class="flex justify-between cursor-help" data-tip="asymmetry_upside"><span class="text-gray-600">Upside ao ATH</span><span class="val-upside text-green-400">--</span></div>
                            <div class="flex justify-between cursor-help" data-tip="asymmetry_downside"><span class="text-gray-600">Downside esperado</span><span class="val-downside text-red-400">--</span></div>
                            <div class="flex justify-between cursor-help" data-tip="asymmetry_ratio"><span class="text-gray-600">Razão R/R</span><span class="val-asymmetry-ratio text-blue-400 font-bold">--</span></div>
                            <div class="asymmetry-recommendation text-center mt-1 text-[9px] font-bold">--</div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                        <div class="bg-dark-950 p-2 rounded border border-gray-800 flex flex-col justify-between">
                            <div>
                                <h5 class="text-[9px] text-gray-500 uppercase font-bold mb-1 border-b border-gray-800 pb-1">Alertas</h5>
                                <div class="alert-list text-[10px] text-gray-300 space-y-1 max-h-20 overflow-y-auto"></div>
                            </div>
                            <button class="w-full bg-brand-900/30 text-brand-500 text-[9px] border border-brand-900 rounded py-1 mt-1 hover:bg-brand-900/50 transition-colors" onclick="App.Alerts.openForCard(this)" data-tip="alert_auto">+ Alerta</button>
                        </div>
                        <div class="bg-dark-950 p-2 rounded border border-gray-800" data-tip="m_history">
                            <h5 class="text-[9px] text-gray-500 uppercase font-bold mb-1 border-b border-gray-800 pb-1">Simulador DCA</h5>
                            <div class="grid grid-cols-2 gap-1 mb-2">
                                <input type="number" class="col-span-2 bg-dark-800 border border-gray-700 rounded px-2 py-1 text-xs" placeholder="Aporte mensal ($)" id="dca-amount">
                                <button class="bg-green-900/20 text-green-500 text-[10px] py-1 rounded border border-green-900/50 hover:bg-green-900/40 transition-colors" onclick="App.Trade.simulateDCA(this)" data-tip="sim_dca">SIMULAR DCA</button>
                                <button class="bg-blue-900/20 text-blue-500 text-[10px] py-1 rounded border border-blue-900/50 hover:bg-blue-900/40 transition-colors" onclick="App.Trade.clearDCA(this)">LIMPAR</button>
                            </div>
                            <div class="trade-list text-[9px] text-gray-600 text-center italic max-h-16 overflow-y-auto">--</div>
                        </div>
                    </div>
                    
                    <div class="bg-dark-950 p-2 rounded border border-gray-800">
                        <h5 class="text-[9px] text-gray-500 uppercase font-bold mb-1 border-b border-gray-800 pb-1 cursor-help" data-tip="analysis_holder">Análise Holder Completa</h5>
                        <div class="analysis-holder-content text-[10px] text-gray-300 space-y-2">
                            <div class="flex justify-between">
                                <span class="cursor-help" data-tip="analysis_cycle">Ciclo:</span>
                                <span class="analysis-cycle">--</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="cursor-help" data-tip="analysis_drawdown">Drawdown ATH:</span>
                                <span class="analysis-drawdown">--</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="cursor-help" data-tip="analysis_supply">Supply Risk:</span>
                                <span class="analysis-supply-risk">--</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="cursor-help" data-tip="analysis_liquidity">Liquidez:</span>
                                <span class="analysis-liquidity">--</span>
                            </div>
                            <div class="analysis-recommendation text-center mt-2 font-bold">--</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </template>

    <script>
        const COINGECKO_API = "https://api.coingecko.com/api/v3";
        const BINANCE_REST = "https://api.binance.com/api/v3/klines";
        const BINANCE_WS = "wss://stream.binance.com:9443/ws/!ticker@arr";

        const App = {
            State: {
                favoriteTokens: JSON.parse(localStorage.getItem('holder_favorites')) || ['bitcoin', 'ethereum', 'binancecoin', 'solana', 'cardano', 'ripple', 'polkadot', 'chainlink', 'litecoin', 'bitcoin-cash'],
                coinGeckoData: {},
                globalData: {},
                coinList: [],
                currentPage: 1,
                coinsPerPage: 100,
                currency: 'usd',
                alerts: JSON.parse(localStorage.getItem('holder_alerts')) || [],
                portfolio: JSON.parse(localStorage.getItem('holder_portfolio')) || [],
                trades: JSON.parse(localStorage.getItem('holder_trades')) || [],
                ws: null,
                charts: {},
                activeCard: null,
                settings: JSON.parse(localStorage.getItem('holder_settings')) || {
                    autoRefresh: true,
                    refreshInterval: 300,
                    alertSounds: true,
                    defaultTimeframe: '4h',
                    coinGeckoCurrency: 'usd',
                    coinGeckoPerPage: 100,
                    coinGeckoAutoRefresh: true,
                    holderMode: true
                },
                activeFilters: {
                    marketcap: null,
                    volume: null,
                    strategy: null
                },
                currentSort: 'holder_score_desc',
                marketCycle: {
                    phase: 'unknown',
                    btcAthDistance: 0,
                    description: 'Analisando ciclo...'
                },
                technicalData: {}
            },

            Library: {
                // Conceitos existentes...
                
                'ath_change': {
                    title: "Distância do All-Time High",
                    what: "Percentual que o preço atual está abaixo do preço máximo histórico (ATH).",
                    interp: "<b>>70% abaixo:</b> Acumulação profunda<br><b>40-70% abaixo:</b> Correção saudável<br><b>20-40% abaixo:</b> Bull avançado<br><b><20% abaixo:</b> Fase de euforia",
                    tip: "Holders procuram oportunidades com drawdown significativo (>50%) em ativos fundamentais sólidos.",
                    factors: "Fórmula: ((ATH - Preço Atual) / ATH) × 100",
                    example: "Preço: $30, ATH: $100 → 70% abaixo do ATH"
                },
                
                'col_technical': {
                    title: "Indicadores Técnicos",
                    what: "RSI, Médias Móveis e MACD para análise de momentum e sobrecompra/sobrevenda.",
                    interp: "<b>RSI < 30:</b> Oversold (oportunidade)<br><b>RSI > 70:</b> Overbought (cautela)<br><b>Preço > MA30:</b> Tendência de alta<br><b>MACD positivo:</b> Momentum positivo",
                    tip: "Holders usam indicadores técnicos para timing de entrada, não para trading diário.",
                    factors: "RSI 14d, Média Móvel 30d, MACD",
                    example: "RSI 25 → Forte oversold, possível reversão"
                },
                
                'asymmetry_ratio': {
                    title: "Razão Assimetria (Risco/Recompensa)",
                    what: "Relação entre potencial de alta (upside) e risco de queda (downside).",
                    interp: "<b>> 3:1:</b> Excelente assimetria<br><b>2:1 a 3:1:</b> Boa assimetria<br><b>1:1 a 2:1:</b> Assimetria neutra<br><b>< 1:1:</b> Risco maior que recompensa",
                    tip: "Holders buscam assimetrias >3:1 onde o potencial de ganho é pelo menos 3x maior que o risco.",
                    factors: "Upside (ATH) vs Downside (suporte técnico ou média 200d)",
                    example: "Upside 300%, Downside 50% → Razão 6:1"
                },
                
                'asymmetry_analysis': {
                    title: "Análise de Assimetria",
                    what: "Avaliação detalhada do perfil risco/recompensa do ativo.",
                    interp: "Combina valuation (distância do ATH) com suportes técnicos para calcular razão ideal.",
                    tip: "Priorize ativos com alta assimetria e fundamentos sólidos para hold de longo prazo.",
                    factors: "Upside ao ATH, Downside até suporte, Volatilidade",
                    example: "BTC: Upside 150% ao ATH, Downside 25% → Assimetria 6:1"
                },
                
                'asymmetry_upside': {
                    title: "Upside Potencial",
                    what: "Potencial de valorização até retornar ao ATH histórico.",
                    interp: "Quanto maior o drawdown atual, maior o upside potencial.",
                    tip: "Upside > 200% é interessante, mas analise fundamentos para validar se o ATH é realista.",
                    factors: "(ATH / Preço Atual - 1) × 100",
                    example: "Preço: $10, ATH: $50 → Upside 400%"
                },
                
                'asymmetry_downside': {
                    title: "Downside Esperado",
                    what: "Risco de queda até os próximos suportes significativos.",
                    interp: "Baseado em suportes históricos, médias móveis ou zonas de acumulação.",
                    tip: "Downside < 30% é aceitável para ativos sólidos. Evite ativos com risco > 50%.",
                    factors: "Média 200d, suportes históricos, bandas de Bollinger",
                    example: "Preço: $10, Suporte: $7 → Downside 30%"
                },
                
                'technical_rsi': {
                    title: "Relative Strength Index (RSI)",
                    what: "Indicador de momentum que mede velocidade e magnitude dos movimentos de preço.",
                    interp: "<b>0-30:</b> Oversold (compra)<br><b>30-70:</b> Neutro<br><b>70-100:</b> Overbought (venda)",
                    tip: "Holders acumulam em RSI < 30 e evitam compras em RSI > 70.",
                    factors: "Média de ganhos/perdas em 14 períodos",
                    example: "RSI 25 → Fortemente oversold"
                },
                
                'technical_ma': {
                    title: "Média Móvel",
                    what: "Preço médio ao longo de um período específico, suavizando flutuações.",
                    interp: "Preço acima da MA indica tendência de alta. MA 30d é boa referência para médio prazo.",
                    tip: "Entradas abaixo da MA 30d geralmente oferecem melhor custo médio.",
                    factors: "Soma de preços / número de períodos",
                    example: "Preço: $45, MA30: $40 → Tendência positiva"
                },
                
                'technical_macd': {
                    title: "Moving Average Convergence Divergence",
                    what: "Indicador que mostra relação entre duas médias móveis exponenciais.",
                    interp: "MACD positivo → momentum de alta. MACD negativo → momentum de baixa.",
                    tip: "Crossovers do MACD podem sinalizar mudanças de tendência importantes.",
                    factors: "EMA12 - EMA26",
                    example: "MACD: +2.5 → Forte momentum positivo"
                },
                
                'technical_volatility': {
                    title: "Volatilidade",
                    what: "Medida da variação dos retornos de um ativo.",
                    interp: "Alta volatilidade = maior risco, maior potencial retorno.",
                    tip: "Holders podem tolerar mais volatilidade em ativos com alta assimetria.",
                    factors: "Desvio padrão dos retornos diários",
                    example: "Volatilidade 5% → Movimento diário típico de ±5%"
                },
                
                'analysis_cycle': {
                    title: "Análise de Ciclo",
                    what: "Posicionamento do ativo no ciclo de mercado atual.",
                    interp: "Identifica fases de acumulação, bull, distribuição e bear.",
                    tip: "Compre em ciclos de acumulação, segure em bull, considere vender em euforia.",
                    factors: "Distância do ATH, tempo desde último ciclo, momentum",
                    example: "Acumulação profunda: >60% abaixo do ATH"
                },
                
                'analysis_drawdown': {
                    title: "Drawdown Máximo",
                    what: "Maior queda percentual do preço desde o pico anterior.",
                    interp: "Drawdowns > 80% são comuns em cripto. Resiliência a drawdowns mostra força.",
                    tip: "Analise como o ativo se comportou em bear markets anteriores.",
                    factors: "Máxima queda histórica",
                    example: "BTC 2018: -84% do ATH"
                },
                
                'analysis_supply': {
                    title: "Risco de Supply",
                    what: "Risco relacionado à inflação de tokens e diluição.",
                    interp: "Tokens com emissão contínua diluem holders. Tokens deflacionários protegem valor.",
                    tip: "Prefira ativos com supply limitado ou mecanismos deflacionários.",
                    factors: "Inflação anual, max supply, burning mechanisms",
                    example: "BTC: 21M fixo, ETH: emissão variável"
                },
                
                'analysis_liquidity': {
                    title: "Análise de Liquidez",
                    what: "Capacidade de comprar/vender grandes quantidades sem impacto significativo.",
                    interp: "Baixa liquidez = maior slippage, dificuldade de saída.",
                    tip: "Para posições grandes, priorize ativos com volume > $100M diários.",
                    factors: "Volume 24h, spread bid-ask, depth do order book",
                    example: "Volume $1B → Alta liquidez"
                }
            },

            Technical: {
                // Calcular RSI com dados históricos
                calculateRSI: (prices, period = 14) => {
                    if (prices.length < period + 1) return 50;
                    
                    let gains = 0;
                    let losses = 0;
                    
                    for (let i = 1; i <= period; i++) {
                        const change = prices[prices.length - i] - prices[prices.length - i - 1];
                        if (change >= 0) {
                            gains += change;
                        } else {
                            losses -= change;
                        }
                    }
                    
                    const avgGain = gains / period;
                    const avgLoss = losses / period;
                    
                    if (avgLoss === 0) return 100;
                    
                    const rs = avgGain / avgLoss;
                    return 100 - (100 / (1 + rs));
                },
                
                // Calcular Média Móvel
                calculateMA: (prices, period = 30) => {
                    if (prices.length < period) return prices[prices.length - 1] || 0;
                    
                    const slice = prices.slice(-period);
                    return slice.reduce((a, b) => a + b, 0) / period;
                },
                
                // Calcular MACD
                calculateMACD: (prices) => {
                    if (prices.length < 26) return 0;
                    
                    // EMA 12
                    let ema12 = prices.slice(-12).reduce((a, b) => a + b, 0) / 12;
                    for (let i = prices.length - 13; i >= 0; i--) {
                        ema12 = (prices[i] * (2 / 13)) + (ema12 * (11 / 13));
                    }
                    
                    // EMA 26
                    let ema26 = prices.slice(-26).reduce((a, b) => a + b, 0) / 26;
                    for (let i = prices.length - 27; i >= 0; i--) {
                        ema26 = (prices[i] * (2 / 27)) + (ema26 * (25 / 27));
                    }
                    
                    return ema12 - ema26;
                },
                
                // Calcular Volatilidade
                calculateVolatility: (prices, period = 30) => {
                    if (prices.length < period) return 0;
                    
                    const returns = [];
                    for (let i = 1; i < period; i++) {
                        const returnPct = (prices[prices.length - i] - prices[prices.length - i - 1]) / prices[prices.length - i - 1];
                        returns.push(returnPct);
                    }
                    
                    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
                    const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
                    
                    return Math.sqrt(variance) * 100; // Volatilidade anualizada aproximada
                },
                
                // Buscar dados históricos para análise técnica
                fetchHistoricalData: async (coinId, days = 90) => {
                    try {
                        const response = await fetch(
                            `${COINGECKO_API}/coins/${coinId}/market_chart?vs_currency=usd&days=${days}`
                        );
                        
                        const data = await response.json();
                        const prices = data.prices.map(p => p[1]);
                        
                        return {
                            prices,
                            rsi: App.Technical.calculateRSI(prices),
                            ma30: App.Technical.calculateMA(prices, 30),
                            macd: App.Technical.calculateMACD(prices),
                            volatility: App.Technical.calculateVolatility(prices, 30)
                        };
                    } catch (error) {
                        console.error(`Erro ao buscar dados históricos de ${coinId}:`, error);
                        return null;
                    }
                }
            },

            CoinGecko: {
                // Funções existentes...
                
                // CALCULAR SCORE HOLDER EVOLUÍDO
                calcHolderScore: async (coin) => {
                    let score = 50;
                    
                    // 1. FUNDAMENTOS & LIQUIDEZ (40%)
                    let fundamentalsScore = 0;
                    
                    // Market Cap Category
                    const mcapCategory = App.CoinGecko.getMarketCapCategory(coin.market_cap);
                    if (mcapCategory === 'large') fundamentalsScore += 15;
                    else if (mcapCategory === 'mid') fundamentalsScore += 10;
                    else if (mcapCategory === 'small') fundamentalsScore += 5;
                    
                    // Volume/MCap Ratio
                    if (coin.market_cap && coin.total_volume) {
                        const ratio = (coin.total_volume / coin.market_cap) * 100;
                        if (ratio > 10) fundamentalsScore += 15;
                        else if (ratio > 5) fundamentalsScore += 10;
                        else if (ratio > 2) fundamentalsScore += 5;
                        else if (ratio < 0.5) fundamentalsScore -= 10;
                    }
                    
                    // Penalizações fortes por baixa liquidez/risco
                    if (coin.market_cap < 50000000) fundamentalsScore -= 20; // < $50M
                    if (coin.total_volume < 5000000) fundamentalsScore -= 15; // < $5M volume
                    
                    fundamentalsScore = Math.max(0, Math.min(40, fundamentalsScore));
                    score += fundamentalsScore;
                    
                    // 2. VALUATION vs HISTÓRICO (30%)
                    let valuationScore = 0;
                    
                    // Distância do ATH
                    if (coin.ath_change_percentage !== undefined) {
                        const athDistance = Math.abs(coin.ath_change_percentage);
                        if (athDistance > 70) valuationScore += 15; // >70% abaixo ATH
                        else if (athDistance > 50) valuationScore += 12;
                        else if (athDistance > 30) valuationScore += 8;
                        else if (athDistance > 10) valuationScore += 4;
                        else if (athDistance < 0) valuationScore -= 15; // Acima do ATH
                    }
                    
                    // Dados técnicos
                    if (App.State.technicalData[coin.id]) {
                        const tech = App.State.technicalData[coin.id];
                        
                        // RSI
                        if (tech.rsi < 30) valuationScore += 8; // Oversold
                        else if (tech.rsi < 40) valuationScore += 4;
                        else if (tech.rsi > 70) valuationScore -= 8; // Overbought
                        
                        // Posição vs MA30
                        if (coin.current_price > tech.ma30 * 1.2) valuationScore -= 5; // Muito acima da média
                        else if (coin.current_price < tech.ma30 * 0.8) valuationScore += 5; // Muito abaixo da média
                    }
                    
                    valuationScore = Math.max(0, Math.min(30, valuationScore));
                    score += valuationScore;
                    
                    // 3. MOMENTUM DE MÉDIO PRAZO (20%)
                    let momentumScore = 0;
                    
                    // Performance 30d
                    if (coin.price_change_percentage_30d_in_currency) {
                        const change30d = coin.price_change_percentage_30d_in_currency;
                        if (change30d < -30) momentumScore += 10; // Muito oversold
                        else if (change30d < -15) momentumScore += 7;
                        else if (change30d < 0) momentumScore += 3;
                        else if (change30d > 30) momentumScore -= 10; // Muito overbought
                        else if (change30d > 15) momentumScore -= 5;
                    }
                    
                    // Performance 90d (se disponível)
                    if (coin.price_change_percentage_90d_in_currency) {
                        const change90d = coin.price_change_percentage_90d_in_currency;
                        if (change90d < -40) momentumScore += 10;
                        else if (change90d < -20) momentumScore += 5;
                        else if (change90d > 50) momentumScore -= 10;
                    }
                    
                    momentumScore = Math.max(0, Math.min(20, momentumScore));
                    score += momentumScore;
                    
                    // 4. RISCO ESTRUTURAL (10%)
                    let riskScore = 0;
                    
                    // Supply Risk
                    if (coin.circulating_supply && coin.max_supply) {
                        const circRatio = (coin.circulating_supply / coin.max_supply) * 100;
                        if (circRatio > 90) riskScore += 7; // Maior parte em circulação
                        else if (circRatio > 70) riskScore += 4;
                        else if (circRatio < 30) riskScore -= 5; // Muita inflação por vir
                    } else if (!coin.max_supply) {
                        riskScore -= 3; // Sem max supply definido
                    }
                    
                    // Volatilidade (penaliza alta volatilidade sem fundamentos)
                    if (App.State.technicalData[coin.id]) {
                        const volatility = App.State.technicalData[coin.id].volatility;
                        if (volatility > 10 && mcapCategory === 'micro') riskScore -= 3;
                    }
                    
                    riskScore = Math.max(0, Math.min(10, riskScore));
                    score += riskScore;
                    
                    // BÔNUS: ASSIMETRIA
                    const asymmetry = App.CoinGecko.calcAsymmetry(coin);
                    if (asymmetry.ratio > 4) score += 15;
                    else if (asymmetry.ratio > 3) score += 10;
                    else if (asymmetry.ratio > 2) score += 5;
                    
                    // Ajustar para 0-100
                    score = Math.max(0, Math.min(100, Math.round(score)));
                    
                    return score;
                },
                
                // CALCULAR ASSIMETRIA
                calcAsymmetry: (coin) => {
                    let upside = 0;
                    let downside = 0;
                    let ratio = 0;
                    
                    // Upside ao ATH
                    if (coin.ath && coin.current_price) {
                        upside = ((coin.ath / coin.current_price) - 1) * 100;
                    }
                    
                    // Downside baseado em suporte técnico
                    if (App.State.technicalData[coin.id]) {
                        const tech = App.State.technicalData[coin.id];
                        
                        // Usar MA30 como suporte aproximado
                        if (tech.ma30 && coin.current_price) {
                            const distanceToMA = ((coin.current_price - tech.ma30) / coin.current_price) * 100;
                            downside = Math.max(15, Math.abs(distanceToMA) * 1.5); // Mínimo 15%, ajustado pela distância
                        } else {
                            downside = 25; // Default
                        }
                        
                        // Ajustar por volatilidade
                        if (tech.volatility) {
                            downside = Math.max(downside, tech.volatility * 2);
                        }
                    } else {
                        downside = 30; // Default
                    }
                    
                    // Calcular razão
                    if (downside > 0) {
                        ratio = upside / downside;
                    }
                    
                    // Classificar assimetria
                    let classification = 'low';
                    if (ratio > 4) classification = 'very-high';
                    else if (ratio > 3) classification = 'high';
                    else if (ratio > 2) classification = 'medium';
                    
                    return {
                        upside: Math.round(upside * 10) / 10,
                        downside: Math.round(downside * 10) / 10,
                        ratio: Math.round(ratio * 10) / 10,
                        classification
                    };
                },
                
                // ATUALIZAR DADOS TÉCNICOS
                updateTechnicalData: async (coinId) => {
                    const techData = await App.Technical.fetchHistoricalData(coinId);
                    if (techData) {
                        App.State.technicalData[coinId] = techData;
                    }
                },
                
                // ANALISAR CICLO DE MERCADO
                analyzeMarketCycle: async () => {
                    try {
                        // Buscar dados do BTC
                        const response = await fetch(
                            `${COINGECKO_API}/coins/bitcoin/market_chart?vs_currency=usd&days=365`
                        );
                        
                        const data = await response.json();
                        const prices = data.prices.map(p => p[1]);
                        const currentPrice = prices[prices.length - 1];
                        const ath = Math.max(...prices);
                        
                        const athDistance = ((ath - currentPrice) / ath) * 100;
                        
                        // Determinar fase do ciclo
                        let phase = 'unknown';
                        let description = '';
                        
                        if (athDistance > 70) {
                            phase = 'accumulation';
                            description = 'Acumulação Profunda';
                        } else if (athDistance > 40) {
                            phase = 'earlybull';
                            description = 'Bull Inicial';
                        } else if (athDistance > 20) {
                            phase = 'midbull';
                            description = 'Bull Avançado';
                        } else if (athDistance > 0) {
                            phase = 'euphoria';
                            description = 'Fase de Euforia';
                        } else {
                            phase = 'bear';
                            description = 'Bear Market';
                        }
                        
                        App.State.marketCycle = {
                            phase,
                            btcAthDistance: Math.round(athDistance * 10) / 10,
                            description
                        };
                        
                        // Atualizar UI
                        document.getElementById('market-cycle').textContent = description;
                        document.getElementById('market-cycle').className = `text-white text-lg font-bold cycle-${phase}`;
                        document.getElementById('cycle-description').textContent = `BTC ${athDistance.toFixed(1)}% abaixo do ATH`;
                        
                    } catch (error) {
                        console.error('Erro ao analisar ciclo:', error);
                    }
                },
                
                // Renderizar tabela atualizada
                renderTable: () => {
                    const tbody = document.getElementById('coingecko-table-body');
                    if (!tbody) return;
                    
                    let coins = Object.values(App.State.coinGeckoData);
                    
                    // Aplicar filtros
                    if (App.State.activeFilters.marketcap) {
                        coins = coins.filter(coin => 
                            App.CoinGecko.getMarketCapCategory(coin.market_cap) === App.State.activeFilters.marketcap
                        );
                    }
                    
                    if (App.State.activeFilters.volume) {
                        coins = coins.filter(coin => {
                            const volCategory = App.CoinGecko.getVolumeCategory(coin.total_volume);
                            if (App.State.activeFilters.volume === 'high') {
                                return volCategory === 'high' || volCategory === 'very-high';
                            } else {
                                return volCategory === 'low';
                            }
                        });
                    }
                    
                    // Aplicar estratégias
                    if (App.State.activeFilters.strategy) {
                        coins = coins.filter(coin => {
                            const score = coin.holderScore || 50;
                            const asymmetry = App.CoinGecko.calcAsymmetry(coin);
                            const tech = App.State.technicalData[coin.id];
                            
                            switch(App.State.activeFilters.strategy) {
                                case 'bluechips':
                                    return App.CoinGecko.getMarketCapCategory(coin.market_cap) === 'large' && score >= 70;
                                case 'correction':
                                    return (coin.ath_change_percentage || 0) > 30 && score >= 60;
                                case 'asymmetry':
                                    return asymmetry.ratio >= 3 && score >= 65;
                                case 'oversold':
                                    return tech && tech.rsi < 35 && score >= 60;
                                default:
                                    return true;
                            }
                        });
                    }
                    
                    // Ordenar
                    coins.sort((a, b) => {
                        const aScore = a.holderScore || 50;
                        const bScore = b.holderScore || 50;
                        const aAsymmetry = App.CoinGecko.calcAsymmetry(a);
                        const bAsymmetry = App.CoinGecko.calcAsymmetry(b);
                        const aTech = App.State.technicalData[a.id];
                        const bTech = App.State.technicalData[b.id];
                        
                        switch(App.State.currentSort) {
                            case 'holder_score_desc': return bScore - aScore;
                            case 'asymmetry_desc': return bAsymmetry.ratio - aAsymmetry.ratio;
                            case 'market_cap_desc': return b.market_cap - a.market_cap;
                            case 'market_cap_asc': return a.market_cap - b.market_cap;
                            case 'volume_desc': return b.total_volume - a.total_volume;
                            case 'ath_change_desc': 
                                return (b.ath_change_percentage || 0) - (a.ath_change_percentage || 0);
                            case 'rsi_asc':
                                return (aTech?.rsi || 50) - (bTech?.rsi || 50);
                            case 'rsi_desc':
                                return (bTech?.rsi || 50) - (aTech?.rsi || 50);
                            default: return bScore - aScore;
                        }
                    });
                    
                    // Atualizar contador
                    document.getElementById('coins-count').textContent = 
                        `${coins.length} criptomoedas carregadas`;
                    
                    // Renderizar linhas
                    tbody.innerHTML = '';
                    
                    coins.forEach((coin, index) => {
                        const score = coin.holderScore || 50;
                        const marketCapCategory = coin.marketCapCategory || 'unknown';
                        const marketCapClass = `badge-marketcap-${marketCapCategory}`;
                        const asymmetry = App.CoinGecko.calcAsymmetry(coin);
                        const tech = App.State.technicalData[coin.id] || { rsi: 50, ma30: 0, macd: 0, volatility: 0 };
                        
                        const row = document.createElement('tr');
                        row.className = `table-row-hover border-b border-gray-800 cursor-pointer ${score > 70 ? 'ranking-row-high' : score < 40 ? 'ranking-row-low' : 'ranking-row-mid'}`;
                        row.onclick = () => App.CoinGecko.openCoinDetail(coin.id);
                        
                        // Cor do RSI
                        let rsiColor = 'text-white';
                        if (tech.rsi < 30) rsiColor = 'text-green-400';
                        else if (tech.rsi > 70) rsiColor = 'text-red-400';
                        
                        // Badge de assimetria
                        let asymmetryBadgeClass = 'asymmetry-low';
                        if (asymmetry.classification === 'very-high') asymmetryBadgeClass = 'asymmetry-very-high';
                        else if (asymmetry.classification === 'high') asymmetryBadgeClass = 'asymmetry-high';
                        else if (asymmetry.classification === 'medium') asymmetryBadgeClass = 'asymmetry-medium';
                        
                        row.innerHTML = `
                            <td class="p-3 text-center text-gray-500 font-bold">${coin.market_cap_rank || '--'}</td>
                            <td class="p-3">
                                <div class="flex items-center gap-2">
                                    <img src="${coin.image}" alt="${coin.name}" class="w-6 h-6 rounded-full">
                                    <div>
                                        <div class="font-bold text-white">${coin.symbol.toUpperCase()}</div>
                                        <div class="text-[10px] text-gray-500">${coin.name}</div>
                                    </div>
                                </div>
                            </td>
                            <td class="p-3 text-center font-mono text-white">${App.CoinGecko.formatCurrency(coin.current_price)}</td>
                            <td class="p-3 text-center">
                                <div class="font-mono">${App.CoinGecko.formatCurrency(coin.market_cap)}</div>
                                <div class="text-[10px] px-2 py-0.5 rounded-full ${marketCapClass} inline-block mt-1">${marketCapCategory.toUpperCase()}</div>
                            </td>
                            <td class="p-3 text-center font-mono">${App.CoinGecko.formatCurrency(coin.total_volume)}</td>
                            <td class="p-3 text-center font-mono ${(coin.ath_change_percentage || 0) > 50 ? 'text-green-400' : 'text-yellow-400'}">
                                ${coin.ath_change_percentage ? coin.ath_change_percentage.toFixed(1) + '%' : '--'}
                            </td>
                            <td class="p-3 text-center font-mono ${rsiColor}">
                                ${tech.rsi ? tech.rsi.toFixed(1) : '--'}
                            </td>
                            <td class="p-3 text-center">
                                <div class="asymmetry-badge ${asymmetryBadgeClass}">${asymmetry.ratio.toFixed(1)}:1</div>
                            </td>
                            <td class="p-3 text-center">
                                <div class="flex flex-col items-center">
                                    <div class="font-bold ${score > 70 ? 'text-green-400' : score < 40 ? 'text-red-400' : 'text-blue-400'}">${score}</div>
                                    <div class="progress-bar w-16 mt-1">
                                        <div class="progress-fill ${score > 70 ? 'bg-green-500' : score < 40 ? 'bg-red-500' : 'bg-blue-500'}" style="width: ${score}%"></div>
                                    </div>
                                </div>
                            </td>
                            <td class="p-3 text-right">
                                <div class="flex gap-2 justify-end">
                                    <button onclick="event.stopPropagation(); App.Token.toggleFavorite('${coin.id}')" class="text-yellow-500 hover:text-yellow-300 p-1" title="${App.State.favoriteTokens.includes(coin.id) ? 'Remover dos favoritos' : 'Adicionar aos favoritos'}">
                                        <i class="fa-solid ${App.State.favoriteTokens.includes(coin.id) ? 'fa-star' : 'fa-star'} ${App.State.favoriteTokens.includes(coin.id) ? '' : 'text-gray-500'}"></i>
                                    </button>
                                    <button onclick="event.stopPropagation(); App.Alerts.openForCoin('${coin.id}')" class="text-orange-500 hover:text-orange-300 p-1" title="Criar alerta">
                                        <i class="fa-solid fa-bell"></i>
                                    </button>
                                </div>
                            </td>
                        `;
                        
                        tbody.appendChild(row);
                    });
                },
                
                // Inicializar dados CoinGecko
                init: async () => {
                    await App.CoinGecko.fetchGlobalData();
                    await App.CoinGecko.analyzeMarketCycle();
                    await App.CoinGecko.fetchCoinList(1);
                    await App.CoinGecko.fetchFullCoinList();
                    
                    // Atualizar dados técnicos para as moedas carregadas
                    const coinIds = Object.keys(App.State.coinGeckoData);
                    for (const coinId of coinIds.slice(0, 20)) { // Limitar a 20 para não sobrecarregar
                        await App.CoinGecko.updateTechnicalData(coinId);
                    }
                    
                    // Configurar auto-refresh
                    if (App.State.settings.coinGeckoAutoRefresh) {
                        setInterval(() => {
                            App.CoinGecko.fetchGlobalData();
                            App.CoinGecko.fetchCoinList(1);
                        }, App.State.settings.refreshInterval * 1000);
                    }
                }
            },

            // UI ATUALIZADA
            UI: {
                tooltips: () => {
                    // Implementação existente...
                    const ov = document.getElementById('metric-tooltip-overlay');
                    const show = (t) => {
                        let d = App.Library[t.dataset.tip];
                        if(!d) return;
                        
                        ov.innerHTML = `
                            <div class="flex-1 min-w-[280px] lg:border-r border-gray-800 lg:pr-6">
                                <h4 class="text-brand-500 font-bold text-lg mb-3">${d.title}</h4>
                                <p class="text-sm text-gray-300 leading-relaxed text-justify">${d.what}</p>
                                ${d.factors ? `<div class="mt-3"><div class="tip-label">Fatores Técnicos</div><p class="tip-val">${d.factors}</p></div>` : ''}
                            </div>
                            <div class="flex-1 min-w-[280px] lg:border-r border-gray-800 lg:pr-6 lg:pl-6">
                                <div class="mb-3">
                                    <div class="tip-label">Interpretação</div>
                                    <p class="tip-val text-justify">${d.interp||'-'}</p>
                                </div>
                            </div>
                            <div class="flex-1 min-w-[250px] lg:pl-6">
                                <div class="bg-brand-900/20 border border-brand-500/30 p-4 rounded-lg shadow-inner">
                                    <div class="tip-label text-brand-400">Dica Holder</div>
                                    <p class="text-xs text-brand-100 italic leading-relaxed">"${d.tip||''}"</p>
                                </div>
                            </div>`;
                        ov.classList.remove('tooltip-hidden'); 
                        ov.classList.add('tooltip-visible');
                    };
                    
                    const hide = () => { 
                        ov.classList.remove('tooltip-visible'); 
                        ov.classList.add('tooltip-hidden'); 
                    };
                    
                    document.body.addEventListener('click', (e) => { 
                        let t = e.target.closest('[data-tip]'); 
                        if(t){ show(t); e.stopPropagation(); } 
                        else if(!e.target.closest('#metric-tooltip-overlay')) hide(); 
                    });
                },
                
                grid: () => {
                    let g = document.getElementById('cards-grid');
                    g.innerHTML='';
                    
                    const favoriteCoins = App.State.favoriteTokens
                        .map(id => App.State.coinGeckoData[id])
                        .filter(coin => coin);
                    
                    favoriteCoins.forEach(coin => {
                        let el = document.getElementById('card-template').content.cloneNode(true).querySelector('.card');
                        el.dataset.symbol = coin.id;
                        
                        el.querySelector('.symbol-ticker').innerText = coin.symbol.toUpperCase();
                        el.querySelector('.token-logo').src = coin.image;
                        el.querySelector('.btn-remove').onclick = (e) => {
                            e.stopPropagation(); 
                            App.Token.rem(coin.id);
                        };
                        
                        App.UI.updateTokenCard(coin.id, el);
                        g.appendChild(el);
                    });
                    
                    if (favoriteCoins.length === 0) {
                        g.innerHTML = `
                            <div class="col-span-full text-center py-12">
                                <i class="fa-regular fa-star text-4xl text-gray-700 mb-4"></i>
                                <h3 class="text-gray-600 font-bold mb-2">Nenhum favorito adicionado</h3>
                                <p class="text-gray-500 text-sm">Adicione criptomoedas usando a busca acima ou clicando no ícone de estrela na tabela.</p>
                            </div>
                        `;
                    }
                },
                
                updateTokenCard: (coinId, cardElement = null) => {
                    const coin = App.State.coinGeckoData[coinId];
                    if (!coin) return;
                    
                    const card = cardElement || document.querySelector(`.card[data-symbol="${coinId}"]`);
                    if (!card) return;
                    
                    // Dados básicos
                    card.querySelector('.price-display').textContent = App.CoinGecko.formatCurrency(coin.current_price);
                    card.querySelector('.price-display').dataset.v = coin.current_price;
                    
                    // Distância do ATH
                    const athDistance = coin.ath_change_percentage || 0;
                    card.querySelector('.percent-display').textContent = athDistance.toFixed(1) + '% do ATH';
                    card.querySelector('.percent-display').className = `text-xs font-bold percent-display ${athDistance > 50 ? 'text-green-400' : athDistance > 20 ? 'text-yellow-400' : 'text-red-400'}`;
                    
                    // Market cap category
                    const marketCapCategory = App.CoinGecko.getMarketCapCategory(coin.market_cap);
                    const marketCapBadge = card.querySelector('.marketcap-badge');
                    marketCapBadge.textContent = marketCapCategory.toUpperCase();
                    marketCapBadge.className = `marketcap-badge text-[8px] font-bold uppercase px-1.5 py-0.5 rounded badge-marketcap-${marketCapCategory}`;
                    
                    // Assimetria
                    const asymmetry = App.CoinGecko.calcAsymmetry(coin);
                    const asymmetryBadge = card.querySelector('.asymmetry-badge');
                    asymmetryBadge.textContent = `${asymmetry.ratio.toFixed(1)}:1`;
                    asymmetryBadge.className = `asymmetry-badge asymmetry-${asymmetry.classification}`;
                    asymmetryBadge.title = `Assimetria ${asymmetry.ratio.toFixed(1)}:1 (Upside: ${asymmetry.upside}%, Downside: ${asymmetry.downside}%)`;
                    
                    // Stats
                    card.querySelector('.metric-rank').textContent = coin.market_cap_rank || '--';
                    card.querySelector('.metric-marketcap').textContent = App.CoinGecko.formatCurrency(coin.market_cap);
                    card.querySelector('.metric-volume').textContent = App.CoinGecko.formatCurrency(coin.total_volume);
                    
                    // Dados técnicos
                    const tech = App.State.technicalData[coinId] || { rsi: 50, ma30: 0, macd: 0, volatility: 0 };
                    card.querySelector('.metric-rsi').textContent = tech.rsi.toFixed(1);
                    card.querySelector('.metric-rsi').className = `metric-rsi ${tech.rsi < 30 ? 'text-green-400' : tech.rsi > 70 ? 'text-red-400' : 'text-white'}`;
                    
                    // Score
                    const score = coin.holderScore || 50;
                    const scoreBadge = card.querySelector('.score-badge');
                    scoreBadge.textContent = score.toFixed(0);
                    scoreBadge.className = `score-badge absolute -bottom-1 -right-1 w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold text-white border border-white shadow-sm cursor-help ${score > 70 ? 'bg-score-high' : score < 40 ? 'bg-score-low' : 'bg-score-mid'}`;
                    scoreBadge.title = `Score Holder: ${score}/100`;
                    
                    // Cor da borda
                    if (score >= 70) {
                        card.style.borderTopColor = '#10b981';
                    } else if (score <= 40) {
                        card.style.borderTopColor = '#ef4444';
                    } else {
                        card.style.borderTopColor = '#3b82f6';
                    }
                    
                    // Seção de Análise Técnica
                    card.querySelector('.val-rsi').textContent = tech.rsi.toFixed(1);
                    card.querySelector('.val-rsi').className = `val-rsi ${tech.rsi < 30 ? 'text-green-400' : tech.rsi > 70 ? 'text-red-400' : 'text-white'}`;
                    
                    card.querySelector('.val-ma').textContent = App.CoinGecko.formatCurrency(tech.ma30);
                    
                    const macdColor = tech.macd > 0 ? 'text-green-400' : 'text-red-400';
                    card.querySelector('.val-macd').textContent = tech.macd.toFixed(4);
                    card.querySelector('.val-macd').className = `val-macd ${macdColor}`;
                    
                    card.querySelector('.val-volatility').textContent = tech.volatility.toFixed(1) + '%';
                    
                    // Seção de Assimetria
                    card.querySelector('.val-upside').textContent = asymmetry.upside.toFixed(1) + '%';
                    card.querySelector('.val-downside').textContent = asymmetry.downside.toFixed(1) + '%';
                    card.querySelector('.val-asymmetry-ratio').textContent = asymmetry.ratio.toFixed(1) + ':1';
                    
                    let asymmetryRec = '';
                    if (asymmetry.ratio > 4) asymmetryRec = '✓ EXCELENTE ASSIMETRIA';
                    else if (asymmetry.ratio > 3) asymmetryRec = '✓ BOA ASSIMETRIA';
                    else if (asymmetry.ratio > 2) asymmetryRec = '∼ ASSIMETRIA MODERADA';
                    else asymmetryRec = '⚠ BAIXA ASSIMETRIA';
                    
                    card.querySelector('.asymmetry-recommendation').textContent = asymmetryRec;
                    card.querySelector('.asymmetry-recommendation').className = `asymmetry-recommendation text-center mt-1 text-[9px] font-bold ${asymmetry.ratio > 3 ? 'text-green-500' : asymmetry.ratio > 2 ? 'text-yellow-500' : 'text-red-500'}`;
                    
                    // Análise Holder Completa
                    const analysisContent = card.querySelector('.analysis-holder-content');
                    if (analysisContent) {
                        // Determinar ciclo do token
                        let cyclePhase = 'unknown';
                        if (athDistance > 70) cyclePhase = 'Acumulação Profunda';
                        else if (athDistance > 40) cyclePhase = 'Correção/Acumulação';
                        else if (athDistance > 20) cyclePhase = 'Bull Avançado';
                        else if (athDistance > 0) cyclePhase = 'Euforia/Topo';
                        else cyclePhase = 'Acima do ATH';
                        
                        // Supply Risk
                        let supplyRisk = 'Médio';
                        if (coin.max_supply && coin.circulating_supply) {
                            const circRatio = (coin.circulating_supply / coin.max_supply) * 100;
                            if (circRatio > 90) supplyRisk = 'Baixo';
                            else if (circRatio > 70) supplyRisk = 'Médio-Baixo';
                            else if (circRatio < 30) supplyRisk = 'Alto';
                        } else if (!coin.max_supply) {
                            supplyRisk = 'Variável';
                        }
                        
                        // Liquidez
                        let liquidity = 'Baixa';
                        const volume = coin.total_volume || 0;
                        if (volume > 100000000) liquidity = 'Muito Alta';
                        else if (volume > 50000000) liquidity = 'Alta';
                        else if (volume > 10000000) liquidity = 'Média';
                        
                        // Recomendação
                        let recommendation = '';
                        let recColor = '';
                        
                        if (score >= 70 && asymmetry.ratio >= 3) {
                            recommendation = '✓ FORTE OPORTUNIDADE DE COMPRA';
                            recColor = 'text-green-500';
                        } else if (score >= 60 && asymmetry.ratio >= 2) {
                            recommendation = '✓ OPORTUNIDADE DE COMPRA';
                            recColor = 'text-green-400';
                        } else if (score <= 40) {
                            recommendation = '⚠ CONSIDERE VENDER/REDUZIR';
                            recColor = 'text-red-500';
                        } else {
                            recommendation = '∼ ACOMPANHAR/AGUARDAR';
                            recColor = 'text-yellow-500';
                        }
                        
                        analysisContent.innerHTML = `
                            <div class="flex justify-between">
                                <span class="cursor-help" data-tip="analysis_cycle">Ciclo:</span>
                                <span class="analysis-cycle ${cyclePhase.includes('Acumulação') ? 'text-green-400' : cyclePhase.includes('Euforia') ? 'text-red-400' : 'text-yellow-400'}">${cyclePhase}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="cursor-help" data-tip="analysis_drawdown">Drawdown ATH:</span>
                                <span class="analysis-drawdown ${athDistance > 50 ? 'text-green-400' : 'text-yellow-400'}">${athDistance.toFixed(1)}%</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="cursor-help" data-tip="analysis_supply">Supply Risk:</span>
                                <span class="analysis-supply-risk ${supplyRisk.includes('Baixo') ? 'text-green-400' : supplyRisk.includes('Alto') ? 'text-red-400' : 'text-yellow-400'}">${supplyRisk}</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="cursor-help" data-tip="analysis_liquidity">Liquidez:</span>
                                <span class="analysis-liquidity ${liquidity.includes('Alta') ? 'text-green-400' : liquidity.includes('Baixa') ? 'text-red-400' : 'text-yellow-400'}">${liquidity}</span>
                            </div>
                            <div class="analysis-recommendation text-center mt-2 font-bold ${recColor}">${recommendation}</div>
                        `;
                    }
                    
                    // Alertas
                    App.Alerts.renderInCard(coinId);
                },
                
                toggleCard: (el) => {
                    let card = el.closest('.card');
                    if(!card) return;
                    
                    let b = card.querySelector('.card-body');
                    if(b.classList.contains('hidden')) {
                        document.querySelectorAll('.card-body').forEach(e=>e.classList.add('hidden'));
                        b.classList.remove('hidden');
                        card.scrollIntoView({behavior:'smooth',block:'center'});
                        
                        let coinId = card.dataset.symbol;
                        let coin = App.State.coinGeckoData[coinId];
                        
                        if(coin && coin.sparkline_in_7d && coin.sparkline_in_7d.price) {
                            let c = card.querySelector('.chart-container');
                            c.innerHTML='';
                            
                            let chart = LightweightCharts.createChart(c, {
                                layout:{background:{color:'#000000'},textColor:'#6b7280'},
                                grid:{vertLines:{color:'#1f2937'},horzLines:{color:'#1f2937'}},
                                width: c.clientWidth,
                                height: c.clientHeight
                            });
                            
                            let s = chart.addAreaSeries({
                                lineColor: '#3b82f6',
                                topColor: 'rgba(59, 130, 246, 0.4)',
                                bottomColor: 'rgba(59, 130, 246, 0.1)',
                                lineWidth: 2
                            });
                            
                            const prices = coin.sparkline_in_7d.price;
                            const data = prices.map((price, index) => ({
                                time: (Date.now() / 1000) - (7 * 24 * 60 * 60) + (index * 60 * 60),
                                value: price
                            }));
                            
                            s.setData(data);
                            chart.timeScale().fitContent();
                        }
                    } else {
                        b.classList.add('hidden');
                    }
                }
            },

            // PORTFÓLIO MANAGEMENT
            Portfolio: {
                openModal: () => {
                    document.getElementById('portfolioModal').classList.remove('hidden');
                    
                    // Popular select de tokens
                    const symbolSelect = document.getElementById('portfolio-symbol');
                    symbolSelect.innerHTML = '<option value="">Selecione um token</option>';
                    
                    App.State.favoriteTokens.forEach(id => {
                        const coin = App.State.coinGeckoData[id];
                        if (coin) {
                            const option = document.createElement('option');
                            option.value = coin.id;
                            option.textContent = `${coin.name} (${coin.symbol.toUpperCase()})`;
                            symbolSelect.appendChild(option);
                        }
                    });
                    
                    App.Portfolio.updatePortfolioView();
                },
                
                closeModal: () => {
                    document.getElementById('portfolioModal').classList.add('hidden');
                },
                
                addPosition: () => {
                    const coinId = document.getElementById('portfolio-symbol').value;
                    const quantity = parseFloat(document.getElementById('portfolio-quantity').value);
                    const avgPrice = parseFloat(document.getElementById('portfolio-avg-price').value);
                    
                    if (!coinId || !quantity || !avgPrice || isNaN(quantity) || isNaN(avgPrice)) {
                        alert('Preencha todos os campos corretamente!');
                        return;
                    }
                    
                    const coin = App.State.coinGeckoData[coinId];
                    if (!coin) {
                        alert('Token não encontrado!');
                        return;
                    }
                    
                    const position = {
                        id: Date.now(),
                        coinId,
                        symbol: coin.symbol.toUpperCase(),
                        name: coin.name,
                        quantity,
                        avgPrice,
                        addedAt: new Date().toLocaleString(),
                        currentPrice: coin.current_price
                    };
                    
                    App.State.portfolio.push(position);
                    App.Portfolio.savePortfolio();
                    App.Portfolio.updatePortfolioView();
                    
                    // Limpar campos
                    document.getElementById('portfolio-quantity').value = '';
                    document.getElementById('portfolio-avg-price').value = '';
                },
                
                removePosition: (id) => {
                    App.State.portfolio = App.State.portfolio.filter(p => p.id !== id);
                    App.Portfolio.savePortfolio();
                    App.Portfolio.updatePortfolioView();
                },
                
                savePortfolio: () => {
                    localStorage.setItem('holder_portfolio', JSON.stringify(App.State.portfolio));
                },
                
                updatePortfolioView: () => {
                    // Atualizar dados das posições
                    App.State.portfolio.forEach(position => {
                        const coin = App.State.coinGeckoData[position.coinId];
                        if (coin) {
                            position.currentPrice = coin.current_price;
                            position.value = position.quantity * position.currentPrice;
                            position.costBasis = position.quantity * position.avgPrice;
                            position.pnl = position.value - position.costBasis;
                            position.pnlPercent = (position.pnl / position.costBasis) * 100;
                        }
                    });
                    
                    // Calcular totais
                    const totalValue = App.State.portfolio.reduce((sum, p) => sum + (p.value || 0), 0);
                    const totalCost = App.State.portfolio.reduce((sum, p) => sum + (p.costBasis || 0), 0);
                    const totalPnl = totalValue - totalCost;
                    const totalPnlPercent = totalCost > 0 ? (totalPnl / totalCost) * 100 : 0;
                    
                    // Calcular score médio ponderado
                    let weightedScoreSum = 0;
                    let totalWeight = 0;
                    
                    App.State.portfolio.forEach(position => {
                        const coin = App.State.coinGeckoData[position.coinId];
                        if (coin && coin.holderScore && position.value) {
                            weightedScoreSum += coin.holderScore * position.value;
                            totalWeight += position.value;
                        }
                    });
                    
                    const avgScore = totalWeight > 0 ? Math.round(weightedScoreSum / totalWeight) : 0;
                    
                    // Atualizar UI
                    document.getElementById('portfolio-total-value').textContent = App.CoinGecko.formatCurrency(totalValue);
                    document.getElementById('portfolio-pnl').textContent = App.CoinGecko.formatCurrency(totalPnl);
                    document.getElementById('portfolio-pnl-percent').textContent = totalPnlPercent.toFixed(2) + '%';
                    document.getElementById('portfolio-pnl-percent').className = `text-sm ${totalPnl >= 0 ? 'text-green-400' : 'text-red-400'}`;
                    document.getElementById('portfolio-avg-score').textContent = avgScore;
                    document.getElementById('portfolio-avg-score').className = `text-white text-2xl font-bold ${avgScore > 70 ? 'text-green-400' : avgScore < 40 ? 'text-red-400' : 'text-blue-400'}`;
                    
                    // Calcular distribuição por market cap
                    const distribution = { large: 0, mid: 0, small: 0, micro: 0 };
                    
                    App.State.portfolio.forEach(position => {
                        const coin = App.State.coinGeckoData[position.coinId];
                        if (coin && position.value) {
                            const category = App.CoinGecko.getMarketCapCategory(coin.market_cap);
                            distribution[category] = (distribution[category] || 0) + position.value;
                        }
                    });
                    
                    // Atualizar distribuição
                    const distributionEl = document.getElementById('portfolio-distribution');
                    distributionEl.innerHTML = '';
                    
                    Object.entries(distribution).forEach(([category, value]) => {
                        const percent = totalValue > 0 ? (value / totalValue) * 100 : 0;
                        distributionEl.innerHTML += `
                            <div class="flex justify-between">
                                <span class="text-gray-400">${category.charAt(0).toUpperCase() + category.slice(1)} Cap:</span>
                                <span class="text-white">${percent.toFixed(1)}%</span>
                            </div>
                        `;
                    });
                    
                    // Atualizar tabela de posições
                    const positionsEl = document.getElementById('portfolio-positions');
                    positionsEl.innerHTML = '';
                    
                    App.State.portfolio.forEach(position => {
                        const coin = App.State.coinGeckoData[position.coinId];
                        const row = document.createElement('tr');
                        row.className = 'border-t border-gray-800';
                        
                        row.innerHTML = `
                            <td class="p-2">
                                <div class="flex items-center gap-2">
                                    <img src="${coin?.image || ''}" alt="${position.symbol}" class="w-5 h-5 rounded-full">
                                    <span class="font-bold">${position.symbol}</span>
                                </div>
                            </td>
                            <td class="p-2 text-right font-mono">${position.quantity.toFixed(6)}</td>
                            <td class="p-2 text-right font-mono">$${position.avgPrice.toFixed(4)}</td>
                            <td class="p-2 text-right font-mono">${App.CoinGecko.formatCurrency(position.value || 0)}</td>
                            <td class="p-2 text-right font-mono ${(position.pnl || 0) >= 0 ? 'text-green-400' : 'text-red-400'}">
                                ${App.CoinGecko.formatCurrency(position.pnl || 0)}<br>
                                <span class="text-xs">${(position.pnlPercent || 0).toFixed(2)}%</span>
                            </td>
                            <td class="p-2 text-right">
                                <span class="${coin?.holderScore > 70 ? 'text-green-400' : coin?.holderScore < 40 ? 'text-red-400' : 'text-blue-400'}">
                                    ${coin?.holderScore || '--'}
                                </span>
                            </td>
                            <td class="p-2 text-right">
                                <button onclick="App.Portfolio.removePosition(${position.id})" class="text-red-500 hover:text-red-300 text-sm">
                                    <i class="fa-solid fa-trash"></i>
                                </button>
                            </td>
                        `;
                        
                        positionsEl.appendChild(row);
                    });
                }
            },

            // ALERTAS ATUALIZADOS
            Alerts: {
                openModal: (btn = null) => {
                    const modal = document.getElementById('alertsModal');
                    const symbolSelect = document.getElementById('alert-symbol');
                    
                    symbolSelect.innerHTML = '<option value="">Selecione um token</option>';
                    
                    App.State.favoriteTokens.forEach(id => {
                        const coin = App.State.coinGeckoData[id];
                        if (coin) {
                            const option = document.createElement('option');
                            option.value = coin.id;
                            option.textContent = `${coin.name} (${coin.symbol.toUpperCase()})`;
                            symbolSelect.appendChild(option);
                        }
                    });
                    
                    // Configurar mudança de tipo de alerta
                    document.getElementById('alert-type').onchange = function() {
                        // Esconder todas as condições
                        document.querySelectorAll('.alert-condition').forEach(el => {
                            el.classList.add('hidden');
                        });
                        
                        // Mostrar a condição correta
                        const conditionId = `alert-condition-${this.value.split('-')[0]}`;
                        const conditionEl = document.getElementById(conditionId);
                        if (conditionEl) {
                            conditionEl.classList.remove('hidden');
                        }
                    };
                    
                    // Pre-selecionar
                    if (btn) {
                        const card = btn.closest('.card');
                        const coinId = card.dataset.symbol;
                        if (coinId) {
                            symbolSelect.value = coinId;
                        }
                    }
                    
                    // Limpar campos
                    document.getElementById('alert-price').value = '';
                    document.getElementById('alert-score-value').value = '';
                    document.getElementById('alert-asymmetry-value').value = '';
                    document.getElementById('alert-notes').value = '';
                    
                    modal.classList.remove('hidden');
                },
                
                createAlert: () => {
                    const coinId = document.getElementById('alert-symbol').value;
                    const type = document.getElementById('alert-type').value;
                    const notes = document.getElementById('alert-notes').value;
                    
                    if (!coinId) {
                        alert('Selecione um token!');
                        return;
                    }
                    
                    const coin = App.State.coinGeckoData[coinId];
                    if (!coin) {
                        alert('Token não encontrado!');
                        return;
                    }
                    
                    let alert = {
                        id: Date.now(),
                        coinId,
                        symbol: coin.symbol.toUpperCase(),
                        type,
                        notes,
                        createdAt: new Date().toLocaleString(),
                        triggered: false,
                        triggeredAt: null
                    };
                    
                    // Configurar condição baseada no tipo
                    if (type === 'buy' || type === 'sell') {
                        const price = parseFloat(document.getElementById('alert-price').value);
                        if (!price || isNaN(price)) {
                            alert('Preço inválido!');
                            return;
                        }
                        
                        alert.targetPrice = price;
                        alert.currentPrice = coin.current_price;
                        alert.conditionType = 'price';
                        
                    } else if (type === 'score') {
                        const condition = document.getElementById('alert-score-condition').value;
                        const value = parseInt(document.getElementById('alert-score-value').value);
                        
                        if (!value || isNaN(value) || value < 0 || value > 100) {
                            alert('Score inválido! Use valores entre 0 e 100.');
                            return;
                        }
                        
                        alert.conditionType = 'score';
                        alert.scoreCondition = condition;
                        alert.scoreValue = value;
                        alert.currentScore = coin.holderScore || 50;
                        
                    } else if (type === 'asymmetry') {
                        const value = parseFloat(document.getElementById('alert-asymmetry-value').value);
                        
                        if (!value || isNaN(value) || value <= 0) {
                            alert('Valor de assimetria inválido!');
                            return;
                        }
                        
                        alert.conditionType = 'asymmetry';
                        alert.asymmetryValue = value;
                        alert.currentAsymmetry = App.CoinGecko.calcAsymmetry(coin).ratio;
                        
                    } else if (type === 'rsi') {
                        alert.conditionType = 'rsi';
                        const tech = App.State.technicalData[coinId] || { rsi: 50 };
                        alert.currentRSI = tech.rsi;
                        
                    } else if (type === 'ath_distance') {
                        alert.conditionType = 'ath_distance';
                        alert.currentAthDistance = coin.ath_change_percentage || 0;
                    }
                    
                    App.State.alerts.push(alert);
                    App.Alerts.saveToStorage();
                    App.Alerts.renderAlertsPanel();
                    App.Alerts.closeModal();
                    App.Alerts.renderInCard(coinId);
                },
                
                checkAllAlerts: () => {
                    App.State.favoriteTokens.forEach(coinId => {
                        const coin = App.State.coinGeckoData[coinId];
                        if (!coin) return;
                        
                        const currentPrice = coin.current_price;
                        const currentScore = coin.holderScore || 50;
                        const currentAsymmetry = App.CoinGecko.calcAsymmetry(coin).ratio;
                        const tech = App.State.technicalData[coinId] || { rsi: 50 };
                        const currentRSI = tech.rsi;
                        const currentAthDistance = coin.ath_change_percentage || 0;
                        
                        App.State.alerts.forEach(alert => {
                            if (alert.coinId === coinId && !alert.triggered) {
                                let shouldTrigger = false;
                                
                                switch(alert.conditionType) {
                                    case 'price':
                                        shouldTrigger = 
                                            (alert.type === 'buy' && currentPrice <= alert.targetPrice) ||
                                            (alert.type === 'sell' && currentPrice >= alert.targetPrice);
                                        break;
                                        
                                    case 'score':
                                        shouldTrigger = 
                                            (alert.scoreCondition === 'above' && currentScore >= alert.scoreValue) ||
                                            (alert.scoreCondition === 'below' && currentScore <= alert.scoreValue);
                                        break;
                                        
                                    case 'asymmetry':
                                        shouldTrigger = currentAsymmetry >= alert.asymmetryValue;
                                        break;
                                        
                                    case 'rsi':
                                        shouldTrigger = currentRSI < 30 || currentRSI > 70;
                                        break;
                                        
                                    case 'ath_distance':
                                        shouldTrigger = Math.abs(currentAthDistance) >= 50;
                                        break;
                                }
                                
                                if (shouldTrigger) {
                                    alert.triggered = true;
                                    alert.triggeredAt = new Date().toLocaleString();
                                    App.Alerts.showNotification(alert);
                                }
                            }
                        });
                    });
                    
                    App.Alerts.saveToStorage();
                    App.Alerts.renderAlertsPanel();
                },
                
                // ... resto das funções de alertas mantidas
            },

            // TRADE SIMULATOR ATUALIZADO
            Trade: {
                simulateDCA: (btn) => {
                    const card = btn.closest('.card');
                    const coinId = card.dataset.symbol;
                    const amount = parseFloat(card.querySelector('#dca-amount').value);
                    
                    if (!amount || isNaN(amount) || amount <= 0) {
                        alert('Digite um valor de aporte válido!');
                        return;
                    }
                    
                    const coin = App.State.coinGeckoData[coinId];
                    if (!coin) return;
                    
                    const price = coin.current_price;
                    const quantity = amount / price;
                    
                    const dcaSim = {
                        id: Date.now(),
                        coinId,
                        symbol: coin.symbol.toUpperCase(),
                        type: 'dca_sim',
                        amount,
                        price,
                        quantity,
                        date: new Date().toLocaleString(),
                        scenario: 'simulado'
                    };
                    
                    // Adicionar ao histórico de trades
                    App.State.trades.push(dcaSim);
                    localStorage.setItem('holder_trades', JSON.stringify(App.State.trades));
                    
                    // Atualizar UI
                    const tradeList = card.querySelector('.trade-list');
                    tradeList.innerHTML = `
                        <div class="text-green-400 text-[9px]">
                            <div>DCA Simulado: $${amount.toFixed(2)}</div>
                            <div>Preço: $${price.toFixed(4)}</div>
                            <div>Qtd: ${quantity.toFixed(6)} ${coin.symbol.toUpperCase()}</div>
                            <div>Custo médio: $${price.toFixed(4)}</div>
                        </div>
                    `;
                    
                    // Limpar campo
                    card.querySelector('#dca-amount').value = '';
                },
                
                clearDCA: (btn) => {
                    const card = btn.closest('.card');
                    const tradeList = card.querySelector('.trade-list');
                    tradeList.innerHTML = '<div class="text-gray-500 text-xs">Simulação limpa</div>';
                },
                
                exec: (btn, type) => {
                    const card = btn.closest('.card');
                    const coinId = card.dataset.symbol;
                    const coin = App.State.coinGeckoData[coinId];
                    
                    if (!coin) return;
                    
                    const price = coin.current_price;
                    const amount = prompt(`Valor em USDT para ${type === 'buy' ? 'COMPRAR' : 'VENDER'} ${coin.symbol.toUpperCase()}:`, "100");
                    
                    if (!amount || isNaN(parseFloat(amount))) return;
                    
                    const quantity = parseFloat(amount) / price;
                    
                    const trade = {
                        id: Date.now(),
                        coinId,
                        symbol: coin.symbol.toUpperCase(),
                        type,
                        amount: parseFloat(amount),
                        price,
                        quantity,
                        date: new Date().toLocaleString()
                    };
                    
                    App.State.trades.push(trade);
                    localStorage.setItem('holder_trades', JSON.stringify(App.State.trades));
                    
                    // Atualizar portfólio se for compra real
                    if (type === 'buy') {
                        const existingPosition = App.State.portfolio.find(p => p.coinId === coinId);
                        
                        if (existingPosition) {
                            // Atualizar posição existente
                            const newQuantity = existingPosition.quantity + quantity;
                            const newAvgPrice = ((existingPosition.quantity * existingPosition.avgPrice) + (quantity * price)) / newQuantity;
                            
                            existingPosition.quantity = newQuantity;
                            existingPosition.avgPrice = newAvgPrice;
                        } else {
                            // Criar nova posição
                            const position = {
                                id: Date.now(),
                                coinId,
                                symbol: coin.symbol.toUpperCase(),
                                name: coin.name,
                                quantity,
                                avgPrice: price,
                                addedAt: new Date().toLocaleString(),
                                currentPrice: price
                            };
                            
                            App.State.portfolio.push(position);
                        }
                        
                        App.Portfolio.savePortfolio();
                    }
                    
                    // Feedback visual
                    btn.textContent = type === 'buy' ? '✓ COMPRADO' : '✓ VENDIDO';
                    btn.className = type === 'buy' ? 'bg-green-900 text-green-300 text-[10px] py-1 rounded border border-green-900' : 'bg-red-900 text-red-300 text-[10px] py-1 rounded border border-red-900';
                    
                    setTimeout(() => {
                        btn.textContent = type === 'buy' ? 'COMPRAR' : 'VENDER';
                        btn.className = type === 'buy' ? 'bg-green-900/20 text-green-500 text-[10px] py-1 rounded border border-green-900/50 hover:bg-green-900/40 transition-colors' : 'bg-red-900/20 text-red-500 text-[10px] py-1 rounded border border-red-900/50 hover:bg-red-900/40 transition-colors';
                    }, 2000);
                }
            },

            // EXPORT ATUALIZADO
            Export: {
                genFavoritesReport: () => {
                    const favoriteCoins = App.State.favoriteTokens
                        .map(id => App.State.coinGeckoData[id])
                        .filter(coin => coin);
                    
                    const data = favoriteCoins.map(coin => {
                        const tech = App.State.technicalData[coin.id] || { rsi: 50, ma30: 0, macd: 0, volatility: 0 };
                        const asymmetry = App.CoinGecko.calcAsymmetry(coin);
                        
                        return {
                            Rank: coin.market_cap_rank || '--',
                            Symbol: coin.symbol.toUpperCase(),
                            Name: coin.name,
                            Price: coin.current_price,
                            'Market Cap': coin.market_cap,
                            'Market Cap Category': App.CoinGecko.getMarketCapCategory(coin.market_cap).toUpperCase(),
                            'Volume 24h': coin.total_volume,
                            'ATH Distance %': coin.ath_change_percentage || 0,
                            'RSI 14d': tech.rsi.toFixed(2),
                            'MA 30d': tech.ma30.toFixed(4),
                            'Upside %': asymmetry.upside,
                            'Downside %': asymmetry.downside,
                            'Asymmetry Ratio': asymmetry.ratio.toFixed(2),
                            'Holder Score': coin.holderScore || 50,
                            'Recommendation': coin.holderScore >= 70 && asymmetry.ratio >= 3 ? 'STRONG BUY' : 
                                             coin.holderScore >= 60 && asymmetry.ratio >= 2 ? 'BUY' :
                                             coin.holderScore <= 40 ? 'CONSIDER SELL' : 'HOLD/WATCH',
                            'Last Updated': new Date().toLocaleString()
                        };
                    });
                    
                    const ws = XLSX.utils.json_to_sheet(data);
                    const wb = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(wb, ws, "Favoritos Holder");
                    XLSX.writeFile(wb, `CryptoPanel_Holder_Favorites_${new Date().toISOString().slice(0,10)}.xlsx`);
                    App.Export.closeModal();
                },
                
                genPortfolio: () => {
                    App.Portfolio.updatePortfolioView();
                    
                    const data = App.State.portfolio.map(position => {
                        const coin = App.State.coinGeckoData[position.coinId];
                        return {
                            Symbol: position.symbol,
                            Name: position.name,
                            Quantity: position.quantity,
                            'Avg Price': position.avgPrice,
                            'Current Price': position.currentPrice || 0,
                            'Position Value': position.value || 0,
                            'Cost Basis': position.costBasis || 0,
                            'P/L $': position.pnl || 0,
                            'P/L %': (position.pnlPercent || 0).toFixed(2),
                            'Holder Score': coin?.holderScore || '--',
                            'Asymmetry': coin ? App.CoinGecko.calcAsymmetry(coin).ratio.toFixed(2) : '--',
                            'Added Date': position.addedAt
                        };
                    });
                    
                    const ws = XLSX.utils.json_to_sheet(data);
                    const wb = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(wb, ws, "Portfolio");
                    XLSX.writeFile(wb, `CryptoPanel_Portfolio_${new Date().toISOString().slice(0,10)}.xlsx`);
                    App.Export.closeModal();
                },
                
                genFullAnalysis: () => {
                    const coins = Object.values(App.State.coinGeckoData);
                    
                    const data = coins.map(coin => {
                        const tech = App.State.technicalData[coin.id] || { rsi: 50, ma30: 0, macd: 0, volatility: 0 };
                        const asymmetry = App.CoinGecko.calcAsymmetry(coin);
                        
                        return {
                            Rank: coin.market_cap_rank || '--',
                            Symbol: coin.symbol.toUpperCase(),
                            Name: coin.name,
                            Price: coin.current_price,
                            'Market Cap': coin.market_cap,
                            'Volume 24h': coin.total_volume,
                            'ATH': coin.ath || 0,
                            'ATH Distance %': coin.ath_change_percentage || 0,
                            '24h Change': coin.price_change_percentage_24h_in_currency || 0,
                            '7d Change': coin.price_change_percentage_7d_in_currency || 0,
                            '30d Change': coin.price_change_percentage_30d_in_currency || 0,
                            'RSI 14d': tech.rsi.toFixed(2),
                            'MA 30d': tech.ma30.toFixed(4),
                            'MACD': tech.macd.toFixed(4),
                            'Volatility %': tech.volatility.toFixed(2),
                            'Upside %': asymmetry.upside,
                            'Downside %': asymmetry.downside,
                            'Asymmetry Ratio': asymmetry.ratio.toFixed(2),
                            'Holder Score': coin.holderScore || 50,
                            'Market Cap Category': App.CoinGecko.getMarketCapCategory(coin.market_cap).toUpperCase(),
                            'Circulating Supply': coin.circulating_supply || 0,
                            'Total Supply': coin.total_supply || 0,
                            'Max Supply': coin.max_supply || 'Infinite',
                            'Is Favorite': App.State.favoriteTokens.includes(coin.id) ? 'YES' : 'NO'
                        };
                    });
                    
                    const ws = XLSX.utils.json_to_sheet(data);
                    const wb = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(wb, ws, "Full Analysis");
                    XLSX.writeFile(wb, `CryptoPanel_Full_Analysis_${new Date().toISOString().slice(0,10)}.xlsx`);
                    App.Export.closeModal();
                }
            },

            // SETTINGS ATUALIZADAS
            Settings: {
                saveCoinGeckoSettings: () => {
                    App.State.settings.coinGeckoCurrency = document.getElementById('currency-select').value;
                    App.State.settings.coinGeckoPerPage = parseInt(document.getElementById('per-page-select').value);
                    App.State.settings.coinGeckoAutoRefresh = document.getElementById('auto-refresh-cg').checked;
                    App.State.settings.refreshInterval = parseInt(document.getElementById('refresh-interval').value);
                    App.State.settings.holderMode = document.getElementById('holder-mode').checked;
                    
                    App.State.currency = App.State.settings.coinGeckoCurrency;
                    App.State.coinsPerPage = App.State.settings.coinGeckoPerPage;
                    
                    localStorage.setItem('holder_settings', JSON.stringify(App.State.settings));
                    
                    // Recarregar dados
                    App.CoinGecko.fetchCoinList(1);
                    
                    App.Settings.closeModal();
                    alert('Configurações salvas! Recarregando dados...');
                }
            },

            // INIT ATUALIZADO
            init: async () => {
                App.UI.tooltips();
                await App.CoinGecko.init();
                await App.Token.loadFavoritesData();
                App.UI.grid();
                App.Portfolio.updatePortfolioView();
                App.Alerts.renderAlertsPanel();
                
                // Configurar estratégias
                document.querySelectorAll('.strategy-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const strategy = this.dataset.strategy;
                        
                        if (App.State.activeFilters.strategy === strategy) {
                            App.State.activeFilters.strategy = null;
                            this.classList.remove('filter-active');
                        } else {
                            App.State.activeFilters.strategy = strategy;
                            
                            document.querySelectorAll('.strategy-btn').forEach(b => {
                                b.classList.remove('filter-active');
                            });
                            
                            this.classList.add('filter-active');
                        }
                        
                        App.CoinGecko.renderTable();
                    });
                });
                
                // Configurar filtros existentes
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const filter = this.dataset.filter;
                        const value = this.dataset.value;
                        
                        if (App.State.activeFilters[filter] === value) {
                            App.State.activeFilters[filter] = null;
                            this.classList.remove('filter-active');
                        } else {
                            App.State.activeFilters[filter] = value;
                            
                            document.querySelectorAll(`.filter-btn[data-filter="${filter}"]`).forEach(b => {
                                b.classList.remove('filter-active');
                            });
                            
                            this.classList.add('filter-active');
                        }
                        
                        App.CoinGecko.renderTable();
                    });
                });
                
                // Configurar ordenação
                document.getElementById('sort-select').addEventListener('change', function() {
                    App.State.currentSort = this.value;
                    App.CoinGecko.renderTable();
                });
                
                // Configurar busca
                document.getElementById('searchToken').addEventListener('input', function(e) {
                    const term = e.target.value.toLowerCase();
                    
                    const rows = document.querySelectorAll('#coingecko-table-body tr');
                    rows.forEach(row => {
                        const text = row.textContent.toLowerCase();
                        row.style.display = text.includes(term) ? '' : 'none';
                    });
                    
                    document.querySelectorAll('.card').forEach(card => {
                        const symbol = card.dataset.symbol.toLowerCase();
                        const coin = App.State.coinGeckoData[symbol];
                        if (coin) {
                            const matches = coin.name.toLowerCase().includes(term) || 
                                          coin.symbol.toLowerCase().includes(term);
                            card.style.display = matches ? 'flex' : 'none';
                        }
                    });
                });
                
                // Configurar atualização manual
                document.getElementById('refreshData').addEventListener('click', async () => {
                    await App.CoinGecko.fetchGlobalData();
                    await App.CoinGecko.analyzeMarketCycle();
                    await App.CoinGecko.fetchCoinList(1);
                    App.Portfolio.updatePortfolioView();
                    document.getElementById('last-update').innerText = new Date().toLocaleTimeString();
                });
                
                // Mobile menu toggle
                document.getElementById('mobile-menu-toggle').addEventListener('click', function() {
                    const controls = document.getElementById('header-controls');
                    controls.classList.toggle('hidden');
                    controls.classList.toggle('flex');
                });
                
                // Configurar auto-check de alertas
                setInterval(() => {
                    App.Alerts.checkAllAlerts();
                }, 60000); // Verificar alertas a cada minuto
                
                // Atualizar timestamp
                document.getElementById('last-update').innerText = new Date().toLocaleTimeString();
                
                console.log('CryptoPanel Holder (v13.5) inicializado!');
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            App.init();
        });
    </script>
</body>
</html>
